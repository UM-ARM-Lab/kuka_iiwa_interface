/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2018-05-31 16:48:35.489274
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59;
x0=IKsin(j[2]);
x1=IKcos(j[2]);
x2=IKcos(j[4]);
x3=IKcos(j[3]);
x4=IKsin(j[4]);
x5=IKcos(j[6]);
x6=IKsin(j[5]);
x7=IKsin(j[3]);
x8=IKcos(j[5]);
x9=IKcos(j[1]);
x10=IKsin(j[1]);
x11=IKsin(j[6]);
x12=IKsin(j[0]);
x13=IKcos(j[0]);
x14=((1.0)*x6);
x15=((0.126)*x0);
x16=((1.0)*x1);
x17=((1.0)*x9);
x18=((1.0)*x8);
x19=((1.0)*x11);
x20=((0.126)*x2);
x21=((0.4)*x1);
x22=((0.126)*x1);
x23=((1.0)*x5);
x24=(x10*x3);
x25=(x2*x3);
x26=(x0*x4);
x27=(x10*x7);
x28=(x3*x9);
x29=(x7*x9);
x30=(x0*x7);
x31=(x0*x2);
x32=(x17*x7);
x33=(x14*x30);
x34=(x18*x30);
x35=((((-1.0)*x16*x29))+x24);
x36=(((x16*x2))+(((-1.0)*x26*x3)));
x37=((((-1.0)*x16*x24))+x32);
x38=((((-1.0)*x0*x25))+(((-1.0)*x16*x4)));
x39=((((-1.0)*x27))+(((-1.0)*x16*x28)));
x40=(((x16*x4))+(((1.0)*x0*x25)));
x41=(((x22*x4))+((x15*x25)));
x42=((((0.4)*x30))+((x15*x7*x8)));
x43=((((-1.0)*x17*x3))+(((-1.0)*x16*x27)));
x44=(((x16*x27))+((x17*x3)));
x45=(x43*x6);
x46=(x2*x39);
x47=(((x10*x31))+((x4*(((((-1.0)*x32))+((x1*x24)))))));
x48=(((x2*x37))+((x10*x26)));
x49=((((-1.0)*x17*x31))+((x4*(((((-1.0)*x27))+(((-1.0)*x1*x28)))))));
x50=(x46+((x26*x9)));
x51=((((-1.0)*x33))+((x38*x8)));
x52=((((-1.0)*x18*x38))+x33);
x53=(x48*x8);
x54=(x11*x51);
x55=(x5*x52);
x56=(((x35*x8))+((x6*(((((-1.0)*x46))+(((-1.0)*x17*x26)))))));
IkReal x60=((1.0)*x29);
x57=(((x8*(((((0.126)*x24))+(((-1.0)*x22*x60))))))+(((-1.0)*x21*x60))+(((0.4)*x24))+(((0.4)*x10))+((x6*(((((-1.0)*x20*x39))+(((-1.0)*x15*x4*x9)))))));
x58=(((x11*((((x50*x8))+((x35*x6))))))+((x49*x5)));
x59=(((x5*(((((-1.0)*x18*x50))+(((-1.0)*x14*x35))))))+((x11*x49)));
eerot[0]=(((x13*x59))+((x12*(((((-1.0)*x19*x36))+(((-1.0)*x23*x52)))))));
eerot[1]=(((x13*x58))+((x12*(((((-1.0)*x19*x51))+(((-1.0)*x23*x36)))))));
eerot[2]=(((x13*x56))+((x12*(((((-1.0)*x14*x40))+x34)))));
eetrans[0]=(((x13*x57))+((x12*(((((-1.0)*x14*x41))+x42)))));
eerot[3]=(((x13*((((x11*x36))+x55))))+((x12*x59)));
eerot[4]=(((x12*x58))+((x13*((x54+((x36*x5)))))));
eerot[5]=(((x13*(((((-1.0)*x34))+((x40*x6))))))+((x12*x56)));
eetrans[1]=(((x12*x57))+((x13*(((((-1.0)*x42))+((x41*x6)))))));
eerot[6]=(((x11*x47))+((x5*((x45+x53)))));
eerot[7]=(((x47*x5))+((x11*(((((-1.0)*x18*x48))+(((-1.0)*x14*x43)))))));
eerot[8]=(((x48*x6))+((x44*x8)));
eetrans[2]=((0.34)+((x21*x27))+(((0.4)*x9))+(((0.4)*x28))+((x8*(((((0.126)*x28))+((x22*x27))))))+((x6*((((x20*x37))+((x10*x15*x4)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j0,cj0,sj0,htj0,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij0[2], _nj0;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij0[0] = -1; _ij0[1] = -1; _nj0 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]), htj0=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((((-1.0)*r10*(IKsin(j0))))+(((-1.0)*r00*(IKcos(j0)))));
new_r01=((((-1.0)*r01*(IKcos(j0))))+(((-1.0)*r11*(IKsin(j0)))));
new_r02=(((r12*(IKsin(j0))))+((r02*(IKcos(j0)))));
IkReal x61=IKcos(j0);
IkReal x62=IKsin(j0);
new_px=((((-0.126)*r02*x61))+((px*x61))+(((-0.126)*r12*x62))+((py*x62)));
new_r10=r20;
new_r11=r21;
new_r12=((-1.0)*r22);
new_py=((0.34)+(((0.126)*r22))+(((-1.0)*pz)));
new_r20=(((r00*(IKsin(j0))))+(((-1.0)*r10*(IKcos(j0)))));
new_r21=(((r01*(IKsin(j0))))+(((-1.0)*r11*(IKcos(j0)))));
new_r22=((((-1.0)*r02*(IKsin(j0))))+((r12*(IKcos(j0)))));
IkReal x63=IKsin(j0);
IkReal x64=IKcos(j0);
new_pz=((((-1.0)*px*x63))+(((-0.126)*r12*x64))+((py*x64))+(((0.126)*r02*x63)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x65=((1.0)*px);
IkReal x66=((1.0)*pz);
IkReal x67=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x67))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x66)));
rxp0_2=((((-1.0)*r10*x65))+((py*r00)));
rxp1_0=((((-1.0)*r21*x67))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x66)));
rxp1_2=((((-1.0)*r11*x65))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x67)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x66)));
rxp2_2=((((-1.0)*r12*x65))+((py*r02)));
{
IkReal j1eval[2];
j1eval[0]=(pp+(((-1.0)*(pz*pz))));
j1eval[1]=((px*px)+(py*py));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x68=((0.4)*r22);
IkReal x69=((1.0)*pz);
IkReal x70=(x68+(((-1.0)*x69)));
IkReal x71=((-1.0)*pz);
IkReal x72=((((-1.0)*x69))+(((-1.0)*x68)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x71);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x71);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x71);
rxp2_2=0;
IkReal gconst0=x70;
IkReal gconst1=x72;
IkReal gconst2=x70;
IkReal gconst3=x72;
IkReal gconst4=x70;
IkReal gconst5=x72;
IkReal gconst6=x70;
IkReal gconst7=x72;
IkReal x73=pz*pz*pz*pz;
IkReal x74=r20*r20;
IkReal x75=r22*r22;
IkReal x76=r21*r21;
IkReal x77=(x73*x76);
IkReal x78=(x73*x75);
IkReal x79=(x73*x74);
j6eval[0]=((IKabs(((((-20.48)*x77))+(((-15.36)*x78))+(((5.12)*x79)))))+(((40.96)*(IKabs((r20*r21*x73)))))+(((2.0)*(IKabs(((((-10.24)*x77))+(((-10.24)*x78)))))))+(IKabs(((((-2.56)*x78))+(((-2.56)*x79))))));
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j5, j6]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x80=pz*pz;
IkReal x81=r20*r20;
IkReal x82=r22*r22;
IkReal x83=r21*r21;
IkReal x84=pz*pz*pz*pz;
IkReal x85=((1.28)*gconst4);
IkReal x86=((0.64)*gconst5);
IkReal x87=((0.64)*gconst0);
IkReal x88=((1.28)*gconst0);
IkReal x89=(gconst1*gconst2);
IkReal x90=((1.28)*gconst1);
IkReal x91=((1.28)*gconst5);
IkReal x92=((0.64)*gconst4);
IkReal x93=((0.64)*gconst1);
IkReal x94=(gconst6*x80);
IkReal x95=((2.56)*x81);
IkReal x96=((5.12)*x81);
IkReal x97=((10.24)*x83);
IkReal x98=(gconst2*gconst5*x80);
IkReal x99=(x80*x82);
IkReal x100=(r20*r21*x84);
IkReal x101=((10.24)*x100);
IkReal x102=(gconst7*x99);
IkReal x103=((-10.24)*x100);
IkReal x104=((1.28)*gconst2*x99);
IkReal x105=((1.024)*r22*x80*x81);
IkReal x106=((4.096)*r22*x80*x83);
IkReal x107=((1.024)*r22*x81*x94);
IkReal x108=(gconst5*x105);
IkReal x109=(gconst5*x106);
IkReal x110=(gconst2*x105);
IkReal x111=(gconst1*x105);
IkReal x112=(x102*x92);
IkReal x113=(x102*x86);
IkReal x114=(x82*x92*x94);
IkReal x115=(x82*x86*x94);
IkReal x116=(gconst5*x94*x95);
IkReal x117=((4.096)*r22*x83*x94);
IkReal x118=(gconst1*x106);
IkReal x119=((1.6384)*x83*x99);
IkReal x120=(x102*x87);
IkReal x121=(gconst2*x86*x99);
IkReal x122=(x95*x98);
IkReal x123=(gconst3*x92*x99);
IkReal x124=(gconst1*x94*x95);
IkReal x125=(gconst3*x86*x99);
IkReal x126=(gconst2*x106);
IkReal x127=(x102*x93);
IkReal x128=(x82*x93*x94);
IkReal x129=(x82*x87*x94);
IkReal x130=(gconst2*x92*x99);
IkReal x131=((0.4096)*x81*x99);
IkReal x132=(gconst2*x87*x99);
IkReal x133=(x80*x89*x95);
IkReal x134=(gconst3*x87*x99);
IkReal x135=(gconst3*x93*x99);
IkReal x136=((0.64)*x89*x99);
IkReal x137=(x111+x107);
IkReal x138=(x110+x118);
IkReal x139=(x117+x108);
IkReal x140=(x135+x134+x136+x133+x132);
IkReal x141=(x113+x112+x116+x115+x114);
IkReal x142=(x130+x127+x124+x125+x122+x123+x120+x121+x128+x129);
op[0]=((((-1.0)*x141))+(((-1.0)*x107))+x131+x108);
op[1]=x103;
op[2]=((((-1.0)*x142))+(((-1.0)*x102*x91))+(((-1.0)*x102*x85))+(((-1.0)*x110))+(((-1.0)*x82*x85*x94))+x137+x119+x109+(((-1.0)*x139))+((gconst5*x94*x96))+(((-1.0)*x82*x91*x94))+(((-1.0)*gconst5*x94*x97)));
op[3]=x103;
op[4]=((((-1.0)*x141))+(((-1.0)*x140))+((x96*x98))+(((-1.0)*gconst3*x91*x99))+(((-1.0)*x102*x90))+(((-1.0)*x102*x88))+(((-1.0)*gconst1*x94*x97))+(((-1.0)*gconst2*x91*x99))+(((-1.0)*x111))+(((3.2768)*x83*x99))+(((-1.0)*x126))+x138+x109+x107+(((-1.0)*x82*x90*x94))+(((-1.0)*x139))+((gconst1*x94*x96))+(((-1.0)*gconst3*x85*x99))+(((-1.0)*x82*x88*x94))+(((-0.8192)*x81*x99))+(((-1.0)*x97*x98))+(((-1.0)*gconst2*x85*x99)));
op[5]=x101;
op[6]=((((-1.0)*gconst3*x90*x99))+(((-1.0)*x142))+((x80*x89*x96))+(((-1.0)*gconst3*x88*x99))+(((-1.0)*x126))+x138+x119+x108+(((-1.0)*x137))+(((-1.0)*x80*x89*x97))+(((-1.0)*gconst2*x88*x99))+(((-1.28)*x89*x99)));
op[7]=x101;
op[8]=((((-1.0)*x140))+(((-1.0)*x110))+x131+x111);
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5eval[1];
IkReal x143=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x143);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x143);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x143);
rxp2_2=0;
j5eval[0]=((IKabs((pz*r22)))+(IKabs((((cj6*pz*r20))+(((-1.0)*pz*r21*sj6))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x144=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x144);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x144);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x144);
rxp2_2=0;
IkReal x145=(r21*sj6);
IkReal x146=(cj6*r20);
j5eval[0]=((IKabs(r22))+(((2.5)*(IKabs(((((0.4)*x146))+(((-0.4)*x145))))))));
j5eval[1]=((r22*r22)+(x146*x146)+(x145*x145)+(((-2.0)*x145*x146)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x147=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x147);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x147);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x147);
rxp2_2=0;
IkReal x148=cj6*cj6;
IkReal x149=sj6*sj6;
IkReal x150=((0.4)*cj6);
IkReal x151=((0.4)*sj6);
IkReal x152=((2.0)*cj6*sj6);
j1eval[0]=(((x149*(r10*r10)))+((x148*(r01*r01)))+((r10*r11*x152))+((x149*(r00*r00)))+((r00*r01*x152))+((x148*(r11*r11))));
j1eval[1]=((IKabs((((r00*x151))+((r01*x150)))))+(IKabs(((((-1.0)*r10*x151))+(((-1.0)*r11*x150))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((IKabs(r22))+(((2.5)*(IKabs(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x153=((0.4)*cj6);
IkReal x154=((0.4)*sj6);
j1eval[0]=((IKabs((((r00*x154))+((r01*x153)))))+(IKabs(((((-1.0)*r10*x154))+(((-1.0)*r11*x153))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x155=((0.4)*cj6);
IkReal x156=((0.4)*sj6);
CheckValue<IkReal> x158 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x156))+(((-1.0)*r11*x155)))),IkReal((((r00*x156))+((r01*x155)))),IKFAST_ATAN2_MAGTHRESH);
if(!x158.valid){
continue;
}
IkReal x157=x158.value;
j1array[0]=((-1.0)*x157);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x157)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x159=((2.0)*cj1);
IkReal x160=(r02*sj1);
CheckValue<IkReal> x161=IKPowWithIntegerCheck(((((2.0)*cj6*r10))+(((-2.0)*r11*sj6))),-1);
if(!x161.valid){
continue;
}
if( IKabs(((x161.value)*((x159+(((-1.0)*x159*(r12*r12)))+(((2.0)*r12*x160)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r12))+(((-1.0)*x160)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x161.value)*((x159+(((-1.0)*x159*(r12*r12)))+(((2.0)*r12*x160))))))+IKsqr((((cj1*r12))+(((-1.0)*x160))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x161.value)*((x159+(((-1.0)*x159*(r12*r12)))+(((2.0)*r12*x160))))), (((cj1*r12))+(((-1.0)*x160))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x162=IKcos(j5);
IkReal x163=IKsin(j5);
IkReal x164=((0.4)*sj1);
IkReal x165=(r01*sj6);
IkReal x166=((0.4)*cj1);
IkReal x167=(cj6*r10);
IkReal x168=(r11*sj6);
IkReal x169=((0.4)*x162);
IkReal x170=((0.4)*cj6*r00);
IkReal x171=((0.4)*x163);
evalcond[0]=((((-1.0)*r12*x166))+x169+((r02*x164)));
evalcond[1]=(((r22*x169))+(((-1.0)*r21*sj6*x171))+((cj6*r20*x171)));
evalcond[2]=(x164+((x163*x170))+((r02*x169))+(((-1.0)*x165*x171)));
evalcond[3]=((((-1.0)*x166))+((x167*x171))+(((-1.0)*x168*x171))+((r12*x169)));
evalcond[4]=((((-1.0)*x166*x167))+x171+((x166*x168))+((cj6*r00*x164))+(((-1.0)*x164*x165)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1099=(cj1*r12);
IkReal x1100=((2.0)*sj1);
CheckValue<IkReal> x1101=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1101.valid){
continue;
}
if( IKabs(((x1101.value)*(((((-2.0)*r02*x1099))+((x1100*(r02*r02)))+(((-1.0)*x1100)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1099+(((-1.0)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1101.value)*(((((-2.0)*r02*x1099))+((x1100*(r02*r02)))+(((-1.0)*x1100))))))+IKsqr((x1099+(((-1.0)*r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1101.value)*(((((-2.0)*r02*x1099))+((x1100*(r02*r02)))+(((-1.0)*x1100))))), (x1099+(((-1.0)*r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1102=IKcos(j5);
IkReal x1103=IKsin(j5);
IkReal x1104=((0.4)*sj1);
IkReal x1105=(r01*sj6);
IkReal x1106=((0.4)*cj1);
IkReal x1107=(cj6*r10);
IkReal x1108=(r11*sj6);
IkReal x1109=((0.4)*x1102);
IkReal x1110=((0.4)*cj6*r00);
IkReal x1111=((0.4)*x1103);
evalcond[0]=(((r02*x1104))+(((-1.0)*r12*x1106))+x1109);
evalcond[1]=((((-1.0)*r21*sj6*x1111))+((cj6*r20*x1111))+((r22*x1109)));
evalcond[2]=(((r02*x1109))+x1104+((x1103*x1110))+(((-1.0)*x1105*x1111)));
evalcond[3]=((((-1.0)*x1108*x1111))+((r12*x1109))+(((-1.0)*x1106))+((x1107*x1111)));
evalcond[4]=(x1111+((cj6*r00*x1104))+(((-1.0)*x1106*x1107))+(((-1.0)*x1104*x1105))+((x1106*x1108)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1112=(cj1*r12);
IkReal x1113=((0.4)*r22);
IkReal x1114=(r02*sj1);
CheckValue<IkReal> x1115=IKPowWithIntegerCheck(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))),-1);
if(!x1115.valid){
continue;
}
if( IKabs(((x1115.value)*((((x1113*x1114))+(((-1.0)*x1112*x1113)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1112+(((-1.0)*x1114)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1115.value)*((((x1113*x1114))+(((-1.0)*x1112*x1113))))))+IKsqr((x1112+(((-1.0)*x1114))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1115.value)*((((x1113*x1114))+(((-1.0)*x1112*x1113))))), (x1112+(((-1.0)*x1114))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1116=IKcos(j5);
IkReal x1117=IKsin(j5);
IkReal x1118=((0.4)*sj1);
IkReal x1119=(r01*sj6);
IkReal x1120=((0.4)*cj1);
IkReal x1121=(cj6*r10);
IkReal x1122=(r11*sj6);
IkReal x1123=((0.4)*x1116);
IkReal x1124=((0.4)*cj6*r00);
IkReal x1125=((0.4)*x1117);
evalcond[0]=(x1123+(((-1.0)*r12*x1120))+((r02*x1118)));
evalcond[1]=(((r22*x1123))+((cj6*r20*x1125))+(((-1.0)*r21*sj6*x1125)));
evalcond[2]=(x1118+((x1117*x1124))+(((-1.0)*x1119*x1125))+((r02*x1123)));
evalcond[3]=(((x1121*x1125))+(((-1.0)*x1122*x1125))+(((-1.0)*x1120))+((r12*x1123)));
evalcond[4]=(x1125+((cj6*r00*x1118))+((x1120*x1122))+(((-1.0)*x1120*x1121))+(((-1.0)*x1118*x1119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1127 = IKatan2WithCheck(IkReal(((0.4)*r22)),IkReal(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1127.valid){
continue;
}
IkReal x1126=x1127.value;
j5array[0]=((-1.0)*x1126);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1126)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1128=(r21*sj6);
IkReal x1129=(cj6*r20);
IkReal x1130=((1.0)*cj5*sj6);
IkReal x1131=((1.0)*cj5*cj6);
j1eval[0]=(x1128+(((-1.0)*x1129)));
j1eval[1]=IKsign(((((-0.4)*x1129))+(((0.4)*x1128))));
j1eval[2]=((IKabs(((((-1.0)*r01*x1131))+(((-1.0)*r00*x1130)))))+(IKabs(((((-1.0)*r11*x1131))+(((-1.0)*r10*x1130))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1132=(cj6*r21);
IkReal x1133=((2.0)*sj5);
IkReal x1134=(r20*sj6);
IkReal x1135=((2.0)*cj5*sj6);
IkReal x1136=((2.0)*cj5*cj6);
j1eval[0]=(x1132+x1134);
j1eval[1]=IKsign(((((2.0)*x1132))+(((2.0)*x1134))));
j1eval[2]=((IKabs(((((-1.0)*r10*x1136))+((r12*x1133))+((r11*x1135)))))+(IKabs((((r01*x1135))+((r02*x1133))+(((-1.0)*r00*x1136))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j1eval[0]=r02;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1137=((2.0)*cj5);
IkReal x1138=((2.0)*r12);
IkReal x1139=(r11*sj5*sj6);
IkReal x1140=(cj6*r10*sj5);
CheckValue<IkReal> x1141=IKPowWithIntegerCheck(r02,-1);
if(!x1141.valid){
continue;
}
if( IKabs(((0.5)*(x1141.value)*((((x1137*(r12*r12)))+(((-1.0)*x1137))+(((-1.0)*x1138*x1139))+((x1138*x1140)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r12))+x1140+(((-1.0)*x1139)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.5)*(x1141.value)*((((x1137*(r12*r12)))+(((-1.0)*x1137))+(((-1.0)*x1138*x1139))+((x1138*x1140))))))+IKsqr((((cj5*r12))+x1140+(((-1.0)*x1139))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.5)*(x1141.value)*((((x1137*(r12*r12)))+(((-1.0)*x1137))+(((-1.0)*x1138*x1139))+((x1138*x1140))))), (((cj5*r12))+x1140+(((-1.0)*x1139))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1142=IKsin(j1);
IkReal x1143=IKcos(j1);
IkReal x1144=((0.4)*sj5);
IkReal x1145=(cj6*r00);
IkReal x1146=(r11*sj6);
IkReal x1147=(r01*sj6);
IkReal x1148=(cj6*r10);
IkReal x1149=((0.4)*cj5);
IkReal x1150=((0.4)*x1143);
IkReal x1151=((0.4)*x1142);
evalcond[0]=(x1149+((r02*x1151))+(((-1.0)*r12*x1150)));
evalcond[1]=(x1151+((r02*x1149))+((x1144*x1145))+(((-1.0)*x1144*x1147)));
evalcond[2]=((((-1.0)*x1150))+((x1144*x1148))+(((-1.0)*x1144*x1146))+((r12*x1149)));
evalcond[3]=((((-1.0)*r10*sj6*x1150))+((r00*sj6*x1151))+((cj6*r01*x1151))+(((-1.0)*cj6*r11*x1150)));
evalcond[4]=(x1144+((x1146*x1150))+(((-1.0)*x1147*x1151))+(((-1.0)*x1148*x1150))+((x1145*x1151)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1152=((2.0)*cj6);
IkReal x1153=((2.0)*sj5);
IkReal x1154=((2.0)*cj5*sj6);
CheckValue<IkReal> x1155=IKPowWithIntegerCheck(IKsign(((((2.0)*r20*sj6))+((r21*x1152)))),-1);
if(!x1155.valid){
continue;
}
CheckValue<IkReal> x1156 = IKatan2WithCheck(IkReal((((r11*x1154))+((r12*x1153))+(((-1.0)*cj5*r10*x1152)))),IkReal((((r02*x1153))+(((-1.0)*cj5*r00*x1152))+((r01*x1154)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1156.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1155.value)))+(x1156.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1157=IKsin(j1);
IkReal x1158=IKcos(j1);
IkReal x1159=((0.4)*sj5);
IkReal x1160=(cj6*r00);
IkReal x1161=(r11*sj6);
IkReal x1162=(r01*sj6);
IkReal x1163=(cj6*r10);
IkReal x1164=((0.4)*cj5);
IkReal x1165=((0.4)*x1158);
IkReal x1166=((0.4)*x1157);
evalcond[0]=(x1164+((r02*x1166))+(((-1.0)*r12*x1165)));
evalcond[1]=(x1166+((x1159*x1160))+((r02*x1164))+(((-1.0)*x1159*x1162)));
evalcond[2]=(((x1159*x1163))+(((-1.0)*x1159*x1161))+((r12*x1164))+(((-1.0)*x1165)));
evalcond[3]=(((cj6*r01*x1166))+(((-1.0)*cj6*r11*x1165))+((r00*sj6*x1166))+(((-1.0)*r10*sj6*x1165)));
evalcond[4]=(x1159+(((-1.0)*x1162*x1166))+(((-1.0)*x1163*x1165))+((x1160*x1166))+((x1161*x1165)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1167=((0.4)*cj6);
IkReal x1168=((0.4)*cj5*sj6);
CheckValue<IkReal> x1169=IKPowWithIntegerCheck(IKsign(((((-1.0)*r20*x1167))+(((0.4)*r21*sj6)))),-1);
if(!x1169.valid){
continue;
}
CheckValue<IkReal> x1170 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1168))+(((-1.0)*cj5*r11*x1167)))),IkReal(((((-1.0)*cj5*r01*x1167))+(((-1.0)*r00*x1168)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1170.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1169.value)))+(x1170.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1171=IKsin(j1);
IkReal x1172=IKcos(j1);
IkReal x1173=((0.4)*sj5);
IkReal x1174=(cj6*r00);
IkReal x1175=(r11*sj6);
IkReal x1176=(r01*sj6);
IkReal x1177=(cj6*r10);
IkReal x1178=((0.4)*cj5);
IkReal x1179=((0.4)*x1172);
IkReal x1180=((0.4)*x1171);
evalcond[0]=(x1178+(((-1.0)*r12*x1179))+((r02*x1180)));
evalcond[1]=(((r02*x1178))+x1180+(((-1.0)*x1173*x1176))+((x1173*x1174)));
evalcond[2]=((((-1.0)*x1173*x1175))+((x1173*x1177))+((r12*x1178))+(((-1.0)*x1179)));
evalcond[3]=((((-1.0)*r10*sj6*x1179))+(((-1.0)*cj6*r11*x1179))+((cj6*r01*x1180))+((r00*sj6*x1180)));
evalcond[4]=((((-1.0)*x1176*x1180))+x1173+((x1174*x1180))+((x1175*x1179))+(((-1.0)*x1177*x1179)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1181=((1.0)*pz);
IkReal x1182=((0.4)*cj6);
IkReal x1183=((0.4)*sj6);
IkReal x1184=((((-1.0)*r11*x1182))+(((-1.0)*r10*x1183)));
IkReal x1185=(((r00*x1183))+((r01*x1182)));
CheckValue<IkReal> x1188 = IKatan2WithCheck(IkReal(x1184),IkReal(x1185),IKFAST_ATAN2_MAGTHRESH);
if(!x1188.valid){
continue;
}
IkReal x1186=((1.0)*(x1188.value));
if((((x1184*x1184)+(x1185*x1185))) < -0.00001)
continue;
CheckValue<IkReal> x1189=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1184*x1184)+(x1185*x1185)))),-1);
if(!x1189.valid){
continue;
}
if( (((-1.0)*(x1189.value)*(((((-1.0)*cj6*r21*x1181))+(((-1.0)*r20*sj6*x1181)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1189.value)*(((((-1.0)*cj6*r21*x1181))+(((-1.0)*r20*sj6*x1181)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1187=((-1.0)*(IKasin(((-1.0)*(x1189.value)*(((((-1.0)*cj6*r21*x1181))+(((-1.0)*r20*sj6*x1181))))))));
j1array[0]=((((-1.0)*x1187))+(((-1.0)*x1186)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1186))+(((1.0)*x1187)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
IkReal x1190=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1190);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1190);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1190);
rxp2_2=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1191=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1191);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1191);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1191);
rxp2_2=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1192=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1192);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1192);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1192);
rxp2_2=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1193=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1193);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1193);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1194=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1194);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1194);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1195=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1195);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1195);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
j5eval[1]=r12;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1196=IKPowWithIntegerCheck(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))),-1);
if(!x1196.valid){
continue;
}
CheckValue<IkReal> x1197=IKPowWithIntegerCheck(r12,-1);
if(!x1197.valid){
continue;
}
if( IKabs((pz*(x1196.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((cj1*(x1197.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((pz*(x1196.value)))+IKsqr((cj1*(x1197.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((pz*(x1196.value)), (cj1*(x1197.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1198=IKcos(j5);
IkReal x1199=IKsin(j5);
IkReal x1200=((1.0)*pz);
IkReal x1201=(cj6*r20);
IkReal x1202=(r21*sj6);
IkReal x1203=(cj6*r00);
IkReal x1204=((0.4)*sj1);
IkReal x1205=(r01*sj6);
IkReal x1206=((0.4)*cj1);
IkReal x1207=((0.4)*x1199);
IkReal x1208=((0.4)*x1198);
IkReal x1209=((0.8)*pz*x1199);
evalcond[0]=(x1208+(((-1.0)*r12*x1206)));
evalcond[1]=(((r12*x1208))+(((-1.0)*x1206)));
evalcond[2]=((((-1.0)*x1202*x1209))+((x1201*x1209)));
evalcond[3]=((((-1.0)*x1202*x1207))+((x1201*x1207))+(((-1.0)*x1200)));
evalcond[4]=(x1204+((x1203*x1207))+(((-1.0)*x1205*x1207)));
evalcond[5]=((((-1.0)*x1204*x1205))+x1207+((x1203*x1204))+(((-1.0)*x1200*x1201))+((pz*x1202)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1210=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1210.valid){
continue;
}
if( IKabs(((-2.0)*sj1*(x1210.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((cj1*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-2.0)*sj1*(x1210.value)))+IKsqr((cj1*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-2.0)*sj1*(x1210.value)), (cj1*r12));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1211=IKcos(j5);
IkReal x1212=IKsin(j5);
IkReal x1213=((1.0)*pz);
IkReal x1214=(cj6*r20);
IkReal x1215=(r21*sj6);
IkReal x1216=(cj6*r00);
IkReal x1217=((0.4)*sj1);
IkReal x1218=(r01*sj6);
IkReal x1219=((0.4)*cj1);
IkReal x1220=((0.4)*x1212);
IkReal x1221=((0.4)*x1211);
IkReal x1222=((0.8)*pz*x1212);
evalcond[0]=(x1221+(((-1.0)*r12*x1219)));
evalcond[1]=((((-1.0)*x1219))+((r12*x1221)));
evalcond[2]=(((x1214*x1222))+(((-1.0)*x1215*x1222)));
evalcond[3]=(((x1214*x1220))+(((-1.0)*x1215*x1220))+(((-1.0)*x1213)));
evalcond[4]=(x1217+(((-1.0)*x1218*x1220))+((x1216*x1220)));
evalcond[5]=(x1220+(((-1.0)*x1217*x1218))+(((-1.0)*x1213*x1214))+((x1216*x1217))+((pz*x1215)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1223=IKPowWithIntegerCheck(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))),-1);
if(!x1223.valid){
continue;
}
if( IKabs((pz*(x1223.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((cj1*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((pz*(x1223.value)))+IKsqr((cj1*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((pz*(x1223.value)), (cj1*r12));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1224=IKcos(j5);
IkReal x1225=IKsin(j5);
IkReal x1226=((1.0)*pz);
IkReal x1227=(cj6*r20);
IkReal x1228=(r21*sj6);
IkReal x1229=(cj6*r00);
IkReal x1230=((0.4)*sj1);
IkReal x1231=(r01*sj6);
IkReal x1232=((0.4)*cj1);
IkReal x1233=((0.4)*x1225);
IkReal x1234=((0.4)*x1224);
IkReal x1235=((0.8)*pz*x1225);
evalcond[0]=(x1234+(((-1.0)*r12*x1232)));
evalcond[1]=((((-1.0)*x1232))+((r12*x1234)));
evalcond[2]=((((-1.0)*x1228*x1235))+((x1227*x1235)));
evalcond[3]=((((-1.0)*x1226))+(((-1.0)*x1228*x1233))+((x1227*x1233)));
evalcond[4]=(x1230+(((-1.0)*x1231*x1233))+((x1229*x1233)));
evalcond[5]=(x1233+(((-1.0)*x1230*x1231))+((pz*x1228))+(((-1.0)*x1226*x1227))+((x1229*x1230)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1236=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1236);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1236);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1237=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1237);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1237);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1238=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1238);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1238);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
j5eval[1]=r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1239=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1239.valid){
continue;
}
CheckValue<IkReal> x1240=IKPowWithIntegerCheck(r22,-1);
if(!x1240.valid){
continue;
}
if( IKabs(((-2.0)*sj1*(x1239.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.5)*pz*(x1240.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-2.0)*sj1*(x1239.value)))+IKsqr(((2.5)*pz*(x1240.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-2.0)*sj1*(x1239.value)), ((2.5)*pz*(x1240.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1241=IKcos(j5);
IkReal x1242=IKsin(j5);
IkReal x1243=((0.4)*cj6);
IkReal x1244=((1.0)*pz);
IkReal x1245=((0.4)*x1241);
IkReal x1246=((0.4)*r01*sj6);
IkReal x1247=((0.4)*r11*sj6);
evalcond[0]=((0.8)*pz*r22*x1241);
evalcond[1]=(x1245+(((-1.0)*r22*x1244)));
evalcond[2]=((((-1.0)*x1244))+((r22*x1245)));
evalcond[3]=(((r00*x1242*x1243))+(((-1.0)*x1242*x1246))+(((0.4)*sj1)));
evalcond[4]=((((-1.0)*x1242*x1247))+((r10*x1242*x1243))+(((-0.4)*cj1)));
evalcond[5]=((((-1.0)*sj1*x1246))+((cj1*x1247))+(((-1.0)*cj1*r10*x1243))+(((0.4)*x1242))+((r00*sj1*x1243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1248=IKPowWithIntegerCheck(((((2.0)*cj6*r10))+(((-2.0)*r11*sj6))),-1);
if(!x1248.valid){
continue;
}
if( IKabs(((2.0)*cj1*(x1248.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.5)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((2.0)*cj1*(x1248.value)))+IKsqr(((2.5)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((2.0)*cj1*(x1248.value)), ((2.5)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1249=IKcos(j5);
IkReal x1250=IKsin(j5);
IkReal x1251=((0.4)*cj6);
IkReal x1252=((1.0)*pz);
IkReal x1253=((0.4)*x1249);
IkReal x1254=((0.4)*r01*sj6);
IkReal x1255=((0.4)*r11*sj6);
evalcond[0]=((0.8)*pz*r22*x1249);
evalcond[1]=(x1253+(((-1.0)*r22*x1252)));
evalcond[2]=((((-1.0)*x1252))+((r22*x1253)));
evalcond[3]=((((0.4)*sj1))+((r00*x1250*x1251))+(((-1.0)*x1250*x1254)));
evalcond[4]=(((r10*x1250*x1251))+(((-1.0)*x1250*x1255))+(((-0.4)*cj1)));
evalcond[5]=(((r00*sj1*x1251))+(((-1.0)*sj1*x1254))+(((-1.0)*cj1*r10*x1251))+((cj1*x1255))+(((0.4)*x1250)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1256=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1256.valid){
continue;
}
if( IKabs(((-2.0)*sj1*(x1256.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.5)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-2.0)*sj1*(x1256.value)))+IKsqr(((2.5)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-2.0)*sj1*(x1256.value)), ((2.5)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1257=IKcos(j5);
IkReal x1258=IKsin(j5);
IkReal x1259=((0.4)*cj6);
IkReal x1260=((1.0)*pz);
IkReal x1261=((0.4)*x1257);
IkReal x1262=((0.4)*r01*sj6);
IkReal x1263=((0.4)*r11*sj6);
evalcond[0]=((0.8)*pz*r22*x1257);
evalcond[1]=(x1261+(((-1.0)*r22*x1260)));
evalcond[2]=(((r22*x1261))+(((-1.0)*x1260)));
evalcond[3]=((((-1.0)*x1258*x1262))+(((0.4)*sj1))+((r00*x1258*x1259)));
evalcond[4]=((((-1.0)*x1258*x1263))+((r10*x1258*x1259))+(((-0.4)*cj1)));
evalcond[5]=(((r00*sj1*x1259))+(((-1.0)*sj1*x1262))+(((-1.0)*cj1*r10*x1259))+((cj1*x1263))+(((0.4)*x1258)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1264=((2.0)*cj1);
IkReal x1265=(r02*sj1);
IkReal x1266=(pz*r22);
CheckValue<IkReal> x1267=IKPowWithIntegerCheck(((((2.0)*cj6*r10))+(((-2.0)*r11*sj6))),-1);
if(!x1267.valid){
continue;
}
if( IKabs(((x1267.value)*((x1264+(((-5.0)*r12*x1266))+(((-1.0)*x1264*(r12*r12)))+(((2.0)*r12*x1265)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((2.5)*x1266))+((cj1*r12))+(((-1.0)*x1265)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1267.value)*((x1264+(((-5.0)*r12*x1266))+(((-1.0)*x1264*(r12*r12)))+(((2.0)*r12*x1265))))))+IKsqr(((((2.5)*x1266))+((cj1*r12))+(((-1.0)*x1265))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1267.value)*((x1264+(((-5.0)*r12*x1266))+(((-1.0)*x1264*(r12*r12)))+(((2.0)*r12*x1265))))), ((((2.5)*x1266))+((cj1*r12))+(((-1.0)*x1265))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1268=IKcos(j5);
IkReal x1269=IKsin(j5);
IkReal x1270=((0.4)*cj6);
IkReal x1271=((0.4)*sj6);
IkReal x1272=(pz*r22);
IkReal x1273=((1.0)*pz);
IkReal x1274=(cj6*r20);
IkReal x1275=((0.4)*cj1);
IkReal x1276=((0.4)*sj1);
IkReal x1277=((0.4)*x1268);
IkReal x1278=(pz*r21*sj6);
IkReal x1279=((0.8)*x1269);
evalcond[0]=(x1277+(((-1.0)*r12*x1275))+((r02*x1276))+(((-1.0)*x1272)));
evalcond[1]=((((-1.0)*r21*x1269*x1271))+(((-1.0)*x1273))+((r22*x1277))+((r20*x1269*x1270)));
evalcond[2]=((((-1.0)*x1278*x1279))+((pz*x1274*x1279))+(((0.8)*x1268*x1272)));
evalcond[3]=(((r00*x1269*x1270))+x1276+((r02*x1277))+(((-1.0)*r01*x1269*x1271)));
evalcond[4]=(((r10*x1269*x1270))+((r12*x1277))+(((-1.0)*x1275))+(((-1.0)*r11*x1269*x1271)));
evalcond[5]=(((r00*sj1*x1270))+x1278+((cj1*r11*x1271))+(((-1.0)*cj1*r10*x1270))+(((-1.0)*x1273*x1274))+(((-1.0)*r01*sj1*x1271))+(((0.4)*x1269)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1280=(cj1*r12);
IkReal x1281=((2.0)*sj1);
IkReal x1282=(pz*r22);
CheckValue<IkReal> x1283=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1283.valid){
continue;
}
if( IKabs(((x1283.value)*((((x1281*(r02*r02)))+(((-2.0)*r02*x1280))+(((-1.0)*x1281))+(((-5.0)*r02*x1282)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1280+(((-1.0)*r02*sj1))+(((2.5)*x1282)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1283.value)*((((x1281*(r02*r02)))+(((-2.0)*r02*x1280))+(((-1.0)*x1281))+(((-5.0)*r02*x1282))))))+IKsqr((x1280+(((-1.0)*r02*sj1))+(((2.5)*x1282))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1283.value)*((((x1281*(r02*r02)))+(((-2.0)*r02*x1280))+(((-1.0)*x1281))+(((-5.0)*r02*x1282))))), (x1280+(((-1.0)*r02*sj1))+(((2.5)*x1282))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1284=IKcos(j5);
IkReal x1285=IKsin(j5);
IkReal x1286=((0.4)*cj6);
IkReal x1287=((0.4)*sj6);
IkReal x1288=(pz*r22);
IkReal x1289=((1.0)*pz);
IkReal x1290=(cj6*r20);
IkReal x1291=((0.4)*cj1);
IkReal x1292=((0.4)*sj1);
IkReal x1293=((0.4)*x1284);
IkReal x1294=(pz*r21*sj6);
IkReal x1295=((0.8)*x1285);
evalcond[0]=((((-1.0)*x1288))+x1293+(((-1.0)*r12*x1291))+((r02*x1292)));
evalcond[1]=(((r20*x1285*x1286))+(((-1.0)*x1289))+((r22*x1293))+(((-1.0)*r21*x1285*x1287)));
evalcond[2]=(((pz*x1290*x1295))+(((0.8)*x1284*x1288))+(((-1.0)*x1294*x1295)));
evalcond[3]=(x1292+(((-1.0)*r01*x1285*x1287))+((r02*x1293))+((r00*x1285*x1286)));
evalcond[4]=((((-1.0)*x1291))+((r12*x1293))+((r10*x1285*x1286))+(((-1.0)*r11*x1285*x1287)));
evalcond[5]=(x1294+(((-1.0)*x1289*x1290))+(((-1.0)*cj1*r10*x1286))+((cj1*r11*x1287))+((r00*sj1*x1286))+(((0.4)*x1285))+(((-1.0)*r01*sj1*x1287)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1296=(cj1*r12);
IkReal x1297=((0.4)*r22);
IkReal x1298=(r02*sj1);
CheckValue<IkReal> x1299=IKPowWithIntegerCheck(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))),-1);
if(!x1299.valid){
continue;
}
if( IKabs(((x1299.value)*((((x1297*x1298))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1296*x1297)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1296+(((2.5)*pz*r22))+(((-1.0)*x1298)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1299.value)*((((x1297*x1298))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1296*x1297))))))+IKsqr((x1296+(((2.5)*pz*r22))+(((-1.0)*x1298))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1299.value)*((((x1297*x1298))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1296*x1297))))), (x1296+(((2.5)*pz*r22))+(((-1.0)*x1298))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1300=IKcos(j5);
IkReal x1301=IKsin(j5);
IkReal x1302=((0.4)*cj6);
IkReal x1303=((0.4)*sj6);
IkReal x1304=(pz*r22);
IkReal x1305=((1.0)*pz);
IkReal x1306=(cj6*r20);
IkReal x1307=((0.4)*cj1);
IkReal x1308=((0.4)*sj1);
IkReal x1309=((0.4)*x1300);
IkReal x1310=(pz*r21*sj6);
IkReal x1311=((0.8)*x1301);
evalcond[0]=(x1309+(((-1.0)*x1304))+(((-1.0)*r12*x1307))+((r02*x1308)));
evalcond[1]=((((-1.0)*x1305))+(((-1.0)*r21*x1301*x1303))+((r22*x1309))+((r20*x1301*x1302)));
evalcond[2]=(((pz*x1306*x1311))+(((-1.0)*x1310*x1311))+(((0.8)*x1300*x1304)));
evalcond[3]=(x1308+((r00*x1301*x1302))+(((-1.0)*r01*x1301*x1303))+((r02*x1309)));
evalcond[4]=(((r10*x1301*x1302))+((r12*x1309))+(((-1.0)*x1307))+(((-1.0)*r11*x1301*x1303)));
evalcond[5]=(x1310+(((-1.0)*r01*sj1*x1303))+(((0.4)*x1301))+((cj1*r11*x1303))+(((-1.0)*x1305*x1306))+((r00*sj1*x1302))+(((-1.0)*cj1*r10*x1302)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1312=((((0.4)*cj6*r20))+(((-0.4)*r21*sj6)));
CheckValue<IkReal> x1315 = IKatan2WithCheck(IkReal(((0.4)*r22)),IkReal(x1312),IKFAST_ATAN2_MAGTHRESH);
if(!x1315.valid){
continue;
}
IkReal x1313=((1.0)*(x1315.value));
if((((((0.16)*(r22*r22)))+(x1312*x1312))) < -0.00001)
continue;
CheckValue<IkReal> x1316=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.16)*(r22*r22)))+(x1312*x1312)))),-1);
if(!x1316.valid){
continue;
}
if( ((pz*(x1316.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1316.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1314=IKasin((pz*(x1316.value)));
j5array[0]=(x1314+(((-1.0)*x1313)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1314))+(((-1.0)*x1313)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1317=IKsin(j5);
IkReal x1318=((0.8)*pz);
evalcond[0]=((((-1.0)*r21*sj6*x1317*x1318))+((cj6*r20*x1317*x1318))+((r22*x1318*(IKcos(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1319=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1319))+(((-1.0)*cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1319)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1319))+(((-1.0)*cj5*r02))))+IKsqr((((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1319))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1319))+(((-1.0)*cj5*r02))), (((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1319))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1320=IKsin(j1);
IkReal x1321=IKcos(j1);
IkReal x1322=((0.4)*sj5);
IkReal x1323=(r11*sj6);
IkReal x1324=(pz*sj6);
IkReal x1325=((1.0)*r20);
IkReal x1326=(cj6*r00);
IkReal x1327=(cj6*pz);
IkReal x1328=(cj6*r10);
IkReal x1329=((0.4)*cj5);
IkReal x1330=(r01*sj6);
IkReal x1331=((0.4)*x1321);
IkReal x1332=((0.4)*x1320);
evalcond[0]=(x1329+(((-1.0)*pz*r22))+(((-1.0)*r12*x1331))+((r02*x1332)));
evalcond[1]=(x1332+(((-1.0)*x1322*x1330))+((x1322*x1326))+((r02*x1329)));
evalcond[2]=((((-1.0)*x1322*x1323))+((x1322*x1328))+((r12*x1329))+(((-1.0)*x1331)));
evalcond[3]=((((-1.0)*x1324*x1325))+((r00*sj6*x1332))+(((-1.0)*r10*sj6*x1331))+(((-1.0)*r21*x1327))+(((-1.0)*cj6*r11*x1331))+((cj6*r01*x1332)));
evalcond[4]=(x1322+(((-1.0)*x1328*x1331))+(((-1.0)*x1330*x1332))+(((-1.0)*x1325*x1327))+((x1326*x1332))+((r21*x1324))+((x1323*x1331)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1333=((0.8)*pz);
CheckValue<IkReal> x1335 = IKatan2WithCheck(IkReal((r22*x1333)),IkReal(((((-1.0)*r21*sj6*x1333))+((cj6*r20*x1333)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1335.valid){
continue;
}
IkReal x1334=x1335.value;
j5array[0]=((-1.0)*x1334);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1334)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1336=IKsin(j5);
IkReal x1337=((0.4)*x1336);
evalcond[0]=((((-1.0)*r21*sj6*x1337))+(((0.4)*r22*(IKcos(j5))))+(((-1.0)*pz))+((cj6*r20*x1337)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1338=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1338))+(((-1.0)*cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1338)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1338))+(((-1.0)*cj5*r02))))+IKsqr((((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1338))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1338))+(((-1.0)*cj5*r02))), (((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1338))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1339=IKsin(j1);
IkReal x1340=IKcos(j1);
IkReal x1341=((0.4)*sj5);
IkReal x1342=(r11*sj6);
IkReal x1343=(pz*sj6);
IkReal x1344=((1.0)*r20);
IkReal x1345=(cj6*r00);
IkReal x1346=(cj6*pz);
IkReal x1347=(cj6*r10);
IkReal x1348=((0.4)*cj5);
IkReal x1349=(r01*sj6);
IkReal x1350=((0.4)*x1340);
IkReal x1351=((0.4)*x1339);
evalcond[0]=(x1348+(((-1.0)*r12*x1350))+(((-1.0)*pz*r22))+((r02*x1351)));
evalcond[1]=(x1351+(((-1.0)*x1341*x1349))+((x1341*x1345))+((r02*x1348)));
evalcond[2]=((((-1.0)*x1350))+(((-1.0)*x1341*x1342))+((x1341*x1347))+((r12*x1348)));
evalcond[3]=(((cj6*r01*x1351))+(((-1.0)*cj6*r11*x1350))+(((-1.0)*r21*x1346))+(((-1.0)*r10*sj6*x1350))+((r00*sj6*x1351))+(((-1.0)*x1343*x1344)));
evalcond[4]=(x1341+((x1345*x1351))+(((-1.0)*x1347*x1350))+((x1342*x1350))+(((-1.0)*x1349*x1351))+((r21*x1343))+(((-1.0)*x1344*x1346)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x1352=((0.4)*r22);
IkReal x1353=((1.0)*pz);
IkReal x1354=(x1352+(((-1.0)*x1353)));
IkReal x1355=((-1.0)*pz);
IkReal x1356=((((-1.0)*x1352))+(((-1.0)*x1353)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1355);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1355);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1355);
rxp2_2=0;
IkReal gconst24=x1354;
IkReal gconst25=x1356;
IkReal gconst26=x1354;
IkReal gconst27=x1356;
IkReal gconst28=x1354;
IkReal gconst29=x1356;
IkReal gconst30=x1354;
IkReal gconst31=x1356;
IkReal x1357=pz*pz*pz*pz;
IkReal x1358=r20*r20;
IkReal x1359=r22*r22;
IkReal x1360=r21*r21;
IkReal x1361=(x1357*x1360);
IkReal x1362=(x1357*x1359);
IkReal x1363=(x1357*x1358);
j6eval[0]=((IKabs(((((5.12)*x1363))+(((-15.36)*x1362))+(((-20.48)*x1361)))))+(IKabs(((((-2.56)*x1362))+(((-2.56)*x1363)))))+(((40.96)*(IKabs((r20*r21*x1357)))))+(((2.0)*(IKabs(((((-10.24)*x1362))+(((-10.24)*x1361))))))));
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j5, j6]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x1364=pz*pz;
IkReal x1365=r20*r20;
IkReal x1366=r22*r22;
IkReal x1367=r21*r21;
IkReal x1368=pz*pz*pz*pz;
IkReal x1369=(gconst25*gconst26);
IkReal x1370=(gconst29*gconst30);
IkReal x1371=(gconst24*gconst27);
IkReal x1372=((4.096)*r22);
IkReal x1373=(gconst25*gconst27);
IkReal x1374=(gconst29*gconst31);
IkReal x1375=(gconst28*gconst30);
IkReal x1376=(gconst26*gconst29);
IkReal x1377=(gconst27*gconst28);
IkReal x1378=(gconst25*gconst30);
IkReal x1379=(gconst26*gconst28);
IkReal x1380=(gconst25*gconst31);
IkReal x1381=(gconst28*gconst31);
IkReal x1382=(gconst24*gconst31);
IkReal x1383=(gconst24*gconst26);
IkReal x1384=((1.024)*r22);
IkReal x1385=(gconst24*gconst30);
IkReal x1386=(gconst27*gconst29);
IkReal x1387=(x1364*x1367);
IkReal x1388=(x1364*x1365);
IkReal x1389=(r20*r21*x1368);
IkReal x1390=((10.24)*x1389);
IkReal x1391=((2.56)*x1388);
IkReal x1392=((0.64)*x1364*x1366);
IkReal x1393=((1.28)*x1364*x1366);
IkReal x1394=((-10.24)*x1389);
IkReal x1395=(gconst30*x1384*x1388);
IkReal x1396=(gconst29*x1384*x1388);
IkReal x1397=(gconst26*x1384*x1388);
IkReal x1398=(gconst29*x1372*x1387);
IkReal x1399=(gconst30*x1372*x1387);
IkReal x1400=(gconst25*x1384*x1388);
IkReal x1401=(x1381*x1392);
IkReal x1402=(x1370*x1391);
IkReal x1403=(x1370*x1392);
IkReal x1404=(x1375*x1392);
IkReal x1405=(x1374*x1392);
IkReal x1406=(gconst25*x1372*x1387);
IkReal x1407=((1.6384)*x1366*x1387);
IkReal x1408=(x1379*x1392);
IkReal x1409=(x1380*x1392);
IkReal x1410=(x1378*x1392);
IkReal x1411=(x1376*x1391);
IkReal x1412=(x1378*x1391);
IkReal x1413=(x1377*x1392);
IkReal x1414=(x1376*x1392);
IkReal x1415=(x1386*x1392);
IkReal x1416=(x1382*x1392);
IkReal x1417=(x1385*x1392);
IkReal x1418=(gconst26*x1372*x1387);
IkReal x1419=((0.4096)*x1366*x1388);
IkReal x1420=(x1369*x1392);
IkReal x1421=(x1383*x1392);
IkReal x1422=(x1373*x1392);
IkReal x1423=(x1371*x1392);
IkReal x1424=(x1369*x1391);
IkReal x1425=(x1397+x1396);
IkReal x1426=(x1418+x1400);
IkReal x1427=(x1398+x1395);
IkReal x1428=(x1421+x1420+x1423+x1422+x1424);
IkReal x1429=(x1403+x1402+x1401+x1405+x1404);
IkReal x1430=(x1410+x1411+x1412+x1413+x1414+x1415+x1416+x1417+x1409+x1408);
op[0]=(x1396+x1419+(((-1.0)*x1395))+(((-1.0)*x1429)));
op[1]=x1394;
op[2]=((((-1.0)*x1375*x1393))+(((-10.24)*x1370*x1387))+(((-1.0)*x1430))+(((-1.0)*x1374*x1393))+(((-1.0)*x1381*x1393))+x1427+x1400+x1407+(((-1.0)*x1370*x1393))+(((5.12)*x1370*x1388))+(((-1.0)*x1399))+(((-1.0)*x1425)));
op[3]=x1394;
op[4]=((((5.12)*x1376*x1388))+(((-1.0)*x1385*x1393))+x1397+(((-0.8192)*x1366*x1388))+(((5.12)*x1378*x1388))+(((3.2768)*x1366*x1387))+(((-1.0)*x1376*x1393))+(((-1.0)*x1382*x1393))+(((-1.0)*x1377*x1393))+(((-1.0)*x1380*x1393))+x1427+x1406+(((-1.0)*x1378*x1393))+(((-10.24)*x1376*x1387))+(((-10.24)*x1378*x1387))+(((-1.0)*x1386*x1393))+(((-1.0)*x1396))+(((-1.0)*x1399))+(((-1.0)*x1426))+(((-1.0)*x1428))+(((-1.0)*x1429))+(((-1.0)*x1379*x1393)));
op[5]=x1390;
op[6]=((((-1.0)*x1383*x1393))+(((-10.24)*x1369*x1387))+(((-1.0)*x1430))+(((5.12)*x1369*x1388))+x1425+x1407+x1406+(((-1.0)*x1369*x1393))+(((-1.0)*x1371*x1393))+(((-1.0)*x1395))+(((-1.0)*x1426))+(((-1.0)*x1373*x1393)));
op[7]=x1390;
op[8]=(x1419+x1400+(((-1.0)*x1397))+(((-1.0)*x1428)));
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5eval[1];
IkReal x1431=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1431);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1431);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1431);
rxp2_2=0;
j5eval[0]=((IKabs((pz*r22)))+(IKabs((((cj6*pz*r20))+(((-1.0)*pz*r21*sj6))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1432=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1432);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1432);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1432);
rxp2_2=0;
IkReal x1433=(r21*sj6);
IkReal x1434=(cj6*r20);
j5eval[0]=((((2.5)*(IKabs(((((0.4)*x1434))+(((-0.4)*x1433)))))))+(IKabs(r22)));
j5eval[1]=((x1434*x1434)+(x1433*x1433)+(r22*r22)+(((-2.0)*x1433*x1434)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x1435=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1435);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1435);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1435);
rxp2_2=0;
IkReal x1436=cj6*cj6;
IkReal x1437=sj6*sj6;
IkReal x1438=((0.4)*cj6);
IkReal x1439=((0.4)*sj6);
IkReal x1440=((2.0)*cj6*sj6);
j1eval[0]=(((r00*r01*x1440))+((x1436*(r11*r11)))+((x1437*(r10*r10)))+((x1436*(r01*r01)))+((r10*r11*x1440))+((x1437*(r00*r00))));
j1eval[1]=((IKabs(((((-1.0)*r11*x1438))+(((-1.0)*r10*x1439)))))+(IKabs((((r01*x1438))+((r00*x1439))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((IKabs(r22))+(((2.5)*(IKabs(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1441=((0.4)*cj6);
IkReal x1442=((0.4)*sj6);
j1eval[0]=((IKabs(((((-1.0)*r10*x1442))+(((-1.0)*r11*x1441)))))+(IKabs((((r00*x1442))+((r01*x1441))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1, j5]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1443=((0.4)*cj6);
IkReal x1444=((0.4)*sj6);
CheckValue<IkReal> x1446 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1444))+(((-1.0)*r11*x1443)))),IkReal((((r00*x1444))+((r01*x1443)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1446.valid){
continue;
}
IkReal x1445=x1446.value;
j1array[0]=((-1.0)*x1445);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1445)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=(cj1*r12);
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x1447=IKsin(j5);
IkReal x1448=((0.4)*x1447);
evalcond[0]=x1448;
evalcond[1]=((((0.4)*r12*(IKcos(j5))))+(((-0.4)*cj1)));
evalcond[2]=((((-1.0)*r21*sj6*x1448))+((cj6*r20*x1448)));
evalcond[3]=(((cj6*r00*x1448))+(((-1.0)*r01*sj6*x1448)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
sj5array[0]=((((-1.0)*cj1*r11*sj6))+((cj1*cj6*r10))+((r01*sj1*sj6))+(((-1.0)*cj6*r00*sj1)));
if( sj5array[0] >= -1-IKFAST_SINCOS_THRESH && sj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKasin(sj5array[0]);
    cj5array[0] = IKcos(j5array[0]);
    sj5array[1] = sj5array[0];
    j5array[1] = j5array[0] > 0 ? (IKPI-j5array[0]) : (-IKPI-j5array[0]);
    cj5array[1] = -cj5array[0];
}
else if( isnan(sj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x1449=IKcos(j5);
IkReal x1450=IKsin(j5);
IkReal x1451=((0.4)*x1449);
IkReal x1452=((0.4)*x1450);
evalcond[0]=x1451;
evalcond[1]=(r22*x1451);
evalcond[2]=((((-1.0)*r01*sj6*x1452))+(((0.4)*sj1))+((cj6*r00*x1452)));
evalcond[3]=(((cj6*r10*x1452))+(((-1.0)*r11*sj6*x1452))+(((-0.4)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1453=((2.0)*cj1);
IkReal x1454=(r02*sj1);
CheckValue<IkReal> x1455=IKPowWithIntegerCheck(((((2.0)*cj6*r10))+(((-2.0)*r11*sj6))),-1);
if(!x1455.valid){
continue;
}
if( IKabs(((x1455.value)*(((((2.0)*r12*x1454))+(((-1.0)*x1453*(r12*r12)))+x1453)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1454))+((cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1455.value)*(((((2.0)*r12*x1454))+(((-1.0)*x1453*(r12*r12)))+x1453))))+IKsqr(((((-1.0)*x1454))+((cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1455.value)*(((((2.0)*r12*x1454))+(((-1.0)*x1453*(r12*r12)))+x1453))), ((((-1.0)*x1454))+((cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1456=IKcos(j5);
IkReal x1457=IKsin(j5);
IkReal x1458=((0.4)*sj1);
IkReal x1459=(r01*sj6);
IkReal x1460=((0.4)*cj1);
IkReal x1461=(cj6*r10);
IkReal x1462=(r11*sj6);
IkReal x1463=((0.4)*x1456);
IkReal x1464=((0.4)*cj6*r00);
IkReal x1465=((0.4)*x1457);
evalcond[0]=(x1463+(((-1.0)*r12*x1460))+((r02*x1458)));
evalcond[1]=(((cj6*r20*x1465))+(((-1.0)*r21*sj6*x1465))+((r22*x1463)));
evalcond[2]=((((-1.0)*x1459*x1465))+x1458+((x1457*x1464))+((r02*x1463)));
evalcond[3]=((((-1.0)*x1460))+((x1461*x1465))+(((-1.0)*x1462*x1465))+((r12*x1463)));
evalcond[4]=((((-1.0)*x1458*x1459))+((cj6*r00*x1458))+((x1460*x1462))+(((-1.0)*x1460*x1461))+x1465);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1466=(cj1*r12);
IkReal x1467=((2.0)*sj1);
CheckValue<IkReal> x1468=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1468.valid){
continue;
}
if( IKabs(((x1468.value)*(((((-2.0)*r02*x1466))+(((-1.0)*x1467))+((x1467*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*sj1))+x1466)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1468.value)*(((((-2.0)*r02*x1466))+(((-1.0)*x1467))+((x1467*(r02*r02)))))))+IKsqr(((((-1.0)*r02*sj1))+x1466))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1468.value)*(((((-2.0)*r02*x1466))+(((-1.0)*x1467))+((x1467*(r02*r02)))))), ((((-1.0)*r02*sj1))+x1466));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1469=IKcos(j5);
IkReal x1470=IKsin(j5);
IkReal x1471=((0.4)*sj1);
IkReal x1472=(r01*sj6);
IkReal x1473=((0.4)*cj1);
IkReal x1474=(cj6*r10);
IkReal x1475=(r11*sj6);
IkReal x1476=((0.4)*x1469);
IkReal x1477=((0.4)*cj6*r00);
IkReal x1478=((0.4)*x1470);
evalcond[0]=(((r02*x1471))+(((-1.0)*r12*x1473))+x1476);
evalcond[1]=(((r22*x1476))+((cj6*r20*x1478))+(((-1.0)*r21*sj6*x1478)));
evalcond[2]=(((r02*x1476))+((x1470*x1477))+x1471+(((-1.0)*x1472*x1478)));
evalcond[3]=(((r12*x1476))+((x1474*x1478))+(((-1.0)*x1475*x1478))+(((-1.0)*x1473)));
evalcond[4]=((((-1.0)*x1471*x1472))+((x1473*x1475))+x1478+(((-1.0)*x1473*x1474))+((cj6*r00*x1471)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1479=(cj1*r12);
IkReal x1480=((0.4)*r22);
IkReal x1481=(r02*sj1);
CheckValue<IkReal> x1482=IKPowWithIntegerCheck(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))),-1);
if(!x1482.valid){
continue;
}
if( IKabs(((x1482.value)*(((((-1.0)*x1479*x1480))+((x1480*x1481)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1481))+x1479)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1482.value)*(((((-1.0)*x1479*x1480))+((x1480*x1481))))))+IKsqr(((((-1.0)*x1481))+x1479))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1482.value)*(((((-1.0)*x1479*x1480))+((x1480*x1481))))), ((((-1.0)*x1481))+x1479));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1483=IKcos(j5);
IkReal x1484=IKsin(j5);
IkReal x1485=((0.4)*sj1);
IkReal x1486=(r01*sj6);
IkReal x1487=((0.4)*cj1);
IkReal x1488=(cj6*r10);
IkReal x1489=(r11*sj6);
IkReal x1490=((0.4)*x1483);
IkReal x1491=((0.4)*cj6*r00);
IkReal x1492=((0.4)*x1484);
evalcond[0]=((((-1.0)*r12*x1487))+x1490+((r02*x1485)));
evalcond[1]=((((-1.0)*r21*sj6*x1492))+((r22*x1490))+((cj6*r20*x1492)));
evalcond[2]=((((-1.0)*x1486*x1492))+((x1484*x1491))+x1485+((r02*x1490)));
evalcond[3]=((((-1.0)*x1487))+((r12*x1490))+((x1488*x1492))+(((-1.0)*x1489*x1492)));
evalcond[4]=((((-1.0)*x1487*x1488))+(((-1.0)*x1485*x1486))+((x1487*x1489))+((cj6*r00*x1485))+x1492);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1494 = IKatan2WithCheck(IkReal(((0.4)*r22)),IkReal(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1494.valid){
continue;
}
IkReal x1493=x1494.value;
j5array[0]=((-1.0)*x1493);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1493)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1495=(r21*sj6);
IkReal x1496=(cj6*r20);
IkReal x1497=((1.0)*cj5*sj6);
IkReal x1498=((1.0)*cj5*cj6);
j1eval[0]=((((-1.0)*x1496))+x1495);
j1eval[1]=IKsign(((((-0.4)*x1496))+(((0.4)*x1495))));
j1eval[2]=((IKabs(((((-1.0)*r00*x1497))+(((-1.0)*r01*x1498)))))+(IKabs(((((-1.0)*r11*x1498))+(((-1.0)*r10*x1497))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1499=(cj6*r21);
IkReal x1500=((2.0)*sj5);
IkReal x1501=(r20*sj6);
IkReal x1502=((2.0)*cj5*sj6);
IkReal x1503=((2.0)*cj5*cj6);
j1eval[0]=(x1501+x1499);
j1eval[1]=IKsign(((((2.0)*x1501))+(((2.0)*x1499))));
j1eval[2]=((IKabs(((((-1.0)*r00*x1503))+((r01*x1502))+((r02*x1500)))))+(IKabs((((r11*x1502))+((r12*x1500))+(((-1.0)*r10*x1503))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j1eval[0]=r02;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs((((r01*sj6))+(((-1.0)*cj6*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r11*sj6))+((cj6*r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj6))+(((-1.0)*cj6*r00))))+IKsqr(((((-1.0)*r11*sj6))+((cj6*r10))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj6))+(((-1.0)*cj6*r00))), ((((-1.0)*r11*sj6))+((cj6*r10))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1504=IKsin(j1);
IkReal x1505=IKcos(j1);
IkReal x1506=((0.4)*sj6);
IkReal x1507=(cj6*r10);
IkReal x1508=((0.4)*cj6);
IkReal x1509=((0.4)*x1505);
IkReal x1510=(r01*x1504);
IkReal x1511=(r00*x1504);
IkReal x1512=((0.4)*x1504);
evalcond[0]=(((r02*x1512))+(((-1.0)*r12*x1509)));
evalcond[1]=((((-1.0)*r01*x1506))+((r00*x1508))+x1512);
evalcond[2]=((((-1.0)*x1509))+(((-1.0)*r11*x1506))+(((0.4)*x1507)));
evalcond[3]=(((x1508*x1510))+((x1506*x1511))+(((-1.0)*r10*x1505*x1506))+(((-1.0)*r11*x1505*x1508)));
evalcond[4]=((0.4)+((x1508*x1511))+(((-1.0)*x1507*x1509))+(((-1.0)*x1506*x1510))+((r11*x1505*x1506)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-1.0)*r01*sj6))+((cj6*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj6*r10))+((r11*sj6)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj6))+((cj6*r00))))+IKsqr(((((-1.0)*cj6*r10))+((r11*sj6))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*r01*sj6))+((cj6*r00))), ((((-1.0)*cj6*r10))+((r11*sj6))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1513=IKsin(j1);
IkReal x1514=IKcos(j1);
IkReal x1515=((0.4)*sj6);
IkReal x1516=(cj6*r10);
IkReal x1517=((0.4)*cj6);
IkReal x1518=((0.4)*x1514);
IkReal x1519=(r01*x1513);
IkReal x1520=(r00*x1513);
IkReal x1521=((0.4)*x1513);
evalcond[0]=(((r02*x1521))+(((-1.0)*r12*x1518)));
evalcond[1]=((((-1.0)*r00*x1517))+((r01*x1515))+x1521);
evalcond[2]=((((-1.0)*x1518))+((r11*x1515))+(((-0.4)*x1516)));
evalcond[3]=((((-1.0)*r10*x1514*x1515))+(((-1.0)*r11*x1514*x1517))+((x1517*x1519))+((x1515*x1520)));
evalcond[4]=((-0.4)+(((-1.0)*x1516*x1518))+(((-1.0)*x1515*x1519))+((x1517*x1520))+((r11*x1514*x1515)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1522=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1522)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1522)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1522))))+IKsqr((((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1522))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1522))), (((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1522))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1523=IKsin(j1);
IkReal x1524=IKcos(j1);
IkReal x1525=((0.4)*sj5);
IkReal x1526=(cj6*r00);
IkReal x1527=(r11*sj6);
IkReal x1528=(r01*sj6);
IkReal x1529=(cj6*r10);
IkReal x1530=((0.4)*x1524);
IkReal x1531=((0.4)*x1523);
evalcond[0]=(((x1525*x1526))+(((-1.0)*x1525*x1528))+x1531);
evalcond[1]=(((x1525*x1529))+(((-1.0)*x1530))+(((-1.0)*x1525*x1527)));
evalcond[2]=(((cj6*r01*x1531))+(((-1.0)*r10*sj6*x1530))+((r00*sj6*x1531))+(((-1.0)*cj6*r11*x1530)));
evalcond[3]=((((-1.0)*x1529*x1530))+((x1527*x1530))+x1525+((x1526*x1531))+(((-1.0)*x1528*x1531)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1532=((2.0)*cj5);
IkReal x1533=((2.0)*r12);
IkReal x1534=(r11*sj5*sj6);
IkReal x1535=(cj6*r10*sj5);
CheckValue<IkReal> x1536=IKPowWithIntegerCheck(r02,-1);
if(!x1536.valid){
continue;
}
if( IKabs(((0.5)*(x1536.value)*(((((-1.0)*x1532))+((x1532*(r12*r12)))+(((-1.0)*x1533*x1534))+((x1533*x1535)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r12))+(((-1.0)*x1534))+x1535)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.5)*(x1536.value)*(((((-1.0)*x1532))+((x1532*(r12*r12)))+(((-1.0)*x1533*x1534))+((x1533*x1535))))))+IKsqr((((cj5*r12))+(((-1.0)*x1534))+x1535))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.5)*(x1536.value)*(((((-1.0)*x1532))+((x1532*(r12*r12)))+(((-1.0)*x1533*x1534))+((x1533*x1535))))), (((cj5*r12))+(((-1.0)*x1534))+x1535));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1537=IKsin(j1);
IkReal x1538=IKcos(j1);
IkReal x1539=((0.4)*sj5);
IkReal x1540=(cj6*r00);
IkReal x1541=(r11*sj6);
IkReal x1542=(r01*sj6);
IkReal x1543=(cj6*r10);
IkReal x1544=((0.4)*cj5);
IkReal x1545=((0.4)*x1538);
IkReal x1546=((0.4)*x1537);
evalcond[0]=(x1544+((r02*x1546))+(((-1.0)*r12*x1545)));
evalcond[1]=(((x1539*x1540))+x1546+((r02*x1544))+(((-1.0)*x1539*x1542)));
evalcond[2]=(((x1539*x1543))+((r12*x1544))+(((-1.0)*x1539*x1541))+(((-1.0)*x1545)));
evalcond[3]=((((-1.0)*r10*sj6*x1545))+(((-1.0)*cj6*r11*x1545))+((r00*sj6*x1546))+((cj6*r01*x1546)));
evalcond[4]=((((-1.0)*x1543*x1545))+((x1541*x1545))+x1539+((x1540*x1546))+(((-1.0)*x1542*x1546)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1547=((2.0)*cj6);
IkReal x1548=((2.0)*sj5);
IkReal x1549=((2.0)*cj5*sj6);
CheckValue<IkReal> x1550 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r10*x1547))+((r12*x1548))+((r11*x1549)))),IkReal((((r02*x1548))+(((-1.0)*cj5*r00*x1547))+((r01*x1549)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1550.valid){
continue;
}
CheckValue<IkReal> x1551=IKPowWithIntegerCheck(IKsign((((r21*x1547))+(((2.0)*r20*sj6)))),-1);
if(!x1551.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1550.value)+(((1.5707963267949)*(x1551.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1552=IKsin(j1);
IkReal x1553=IKcos(j1);
IkReal x1554=((0.4)*sj5);
IkReal x1555=(cj6*r00);
IkReal x1556=(r11*sj6);
IkReal x1557=(r01*sj6);
IkReal x1558=(cj6*r10);
IkReal x1559=((0.4)*cj5);
IkReal x1560=((0.4)*x1553);
IkReal x1561=((0.4)*x1552);
evalcond[0]=(x1559+(((-1.0)*r12*x1560))+((r02*x1561)));
evalcond[1]=(x1561+((x1554*x1555))+((r02*x1559))+(((-1.0)*x1554*x1557)));
evalcond[2]=(((r12*x1559))+((x1554*x1558))+(((-1.0)*x1560))+(((-1.0)*x1554*x1556)));
evalcond[3]=((((-1.0)*cj6*r11*x1560))+((r00*sj6*x1561))+((cj6*r01*x1561))+(((-1.0)*r10*sj6*x1560)));
evalcond[4]=(((x1555*x1561))+((x1556*x1560))+(((-1.0)*x1557*x1561))+x1554+(((-1.0)*x1558*x1560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1562=((0.4)*cj6);
IkReal x1563=((0.4)*cj5*sj6);
CheckValue<IkReal> x1564=IKPowWithIntegerCheck(IKsign(((((-1.0)*r20*x1562))+(((0.4)*r21*sj6)))),-1);
if(!x1564.valid){
continue;
}
CheckValue<IkReal> x1565 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r11*x1562))+(((-1.0)*r10*x1563)))),IkReal(((((-1.0)*r00*x1563))+(((-1.0)*cj5*r01*x1562)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1565.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1564.value)))+(x1565.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1566=IKsin(j1);
IkReal x1567=IKcos(j1);
IkReal x1568=((0.4)*sj5);
IkReal x1569=(cj6*r00);
IkReal x1570=(r11*sj6);
IkReal x1571=(r01*sj6);
IkReal x1572=(cj6*r10);
IkReal x1573=((0.4)*cj5);
IkReal x1574=((0.4)*x1567);
IkReal x1575=((0.4)*x1566);
evalcond[0]=(x1573+((r02*x1575))+(((-1.0)*r12*x1574)));
evalcond[1]=(((x1568*x1569))+(((-1.0)*x1568*x1571))+x1575+((r02*x1573)));
evalcond[2]=(((r12*x1573))+((x1568*x1572))+(((-1.0)*x1568*x1570))+(((-1.0)*x1574)));
evalcond[3]=((((-1.0)*r10*sj6*x1574))+(((-1.0)*cj6*r11*x1574))+((r00*sj6*x1575))+((cj6*r01*x1575)));
evalcond[4]=((((-1.0)*x1571*x1575))+((x1569*x1575))+(((-1.0)*x1572*x1574))+((x1570*x1574))+x1568);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1576=((1.0)*pz);
IkReal x1577=((0.4)*cj6);
IkReal x1578=((0.4)*sj6);
IkReal x1579=((((-1.0)*r10*x1578))+(((-1.0)*r11*x1577)));
IkReal x1580=(((r01*x1577))+((r00*x1578)));
CheckValue<IkReal> x1583 = IKatan2WithCheck(IkReal(x1579),IkReal(x1580),IKFAST_ATAN2_MAGTHRESH);
if(!x1583.valid){
continue;
}
IkReal x1581=((1.0)*(x1583.value));
if((((x1579*x1579)+(x1580*x1580))) < -0.00001)
continue;
CheckValue<IkReal> x1584=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1579*x1579)+(x1580*x1580)))),-1);
if(!x1584.valid){
continue;
}
if( (((-1.0)*(x1584.value)*(((((-1.0)*cj6*r21*x1576))+(((-1.0)*r20*sj6*x1576)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1584.value)*(((((-1.0)*cj6*r21*x1576))+(((-1.0)*r20*sj6*x1576)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1582=((-1.0)*(IKasin(((-1.0)*(x1584.value)*(((((-1.0)*cj6*r21*x1576))+(((-1.0)*r20*sj6*x1576))))))));
j1array[0]=((((-1.0)*x1582))+(((-1.0)*x1581)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1581))+(((1.0)*x1582)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
IkReal x1585=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1585);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1585);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1585);
rxp2_2=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1586=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1586);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1586);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1586);
rxp2_2=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1587=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1587);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1587);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1587);
rxp2_2=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x1590 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1590)==0){
continue;
}
IkReal x1588=pow(x1590,-0.5);
IkReal x1589=((-1.0)*x1588);
CheckValue<IkReal> x1591 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1591.valid){
continue;
}
IkReal gconst48=((-1.0)*(x1591.value));
IkReal gconst49=(r10*x1589);
IkReal gconst50=(r11*x1589);
CheckValue<IkReal> x1592 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1592.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j6+(x1592.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1593=(cj1*r12);
IkReal x1594=((0.4)*r22);
IkReal x1595=(r02*sj1);
CheckValue<IkReal> x1596=IKPowWithIntegerCheck(((((0.4)*gconst50*r20))+(((-0.4)*gconst49*r21))),-1);
if(!x1596.valid){
continue;
}
if( IKabs(((x1596.value)*((((x1594*x1595))+(((-1.0)*x1593*x1594))+(((-1.0)*pz*(r22*r22)))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((2.5)*pz*r22))+x1593+(((-1.0)*x1595)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1596.value)*((((x1594*x1595))+(((-1.0)*x1593*x1594))+(((-1.0)*pz*(r22*r22)))+pz))))+IKsqr(((((2.5)*pz*r22))+x1593+(((-1.0)*x1595))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1596.value)*((((x1594*x1595))+(((-1.0)*x1593*x1594))+(((-1.0)*pz*(r22*r22)))+pz))), ((((2.5)*pz*r22))+x1593+(((-1.0)*x1595))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1597=IKcos(j5);
IkReal x1598=IKsin(j5);
IkReal x1599=((0.4)*gconst49);
IkReal x1600=(gconst50*r20);
IkReal x1601=((0.8)*pz);
IkReal x1602=((1.0)*pz);
IkReal x1603=(gconst50*r10);
IkReal x1604=((0.4)*cj1);
IkReal x1605=((0.4)*sj1);
IkReal x1606=(gconst50*r00);
IkReal x1607=((0.4)*x1597);
IkReal x1608=(gconst49*pz*r21);
IkReal x1609=((0.4)*x1598);
evalcond[0]=(x1607+(((-1.0)*r22*x1602))+(((-1.0)*r12*x1604))+((r02*x1605)));
evalcond[1]=((((-1.0)*x1602))+((x1600*x1609))+((r22*x1607))+(((-1.0)*r21*x1598*x1599)));
evalcond[2]=(((r22*x1597*x1601))+(((-1.0)*gconst49*r21*x1598*x1601))+((x1598*x1600*x1601)));
evalcond[3]=(x1605+((r02*x1607))+((x1606*x1609))+(((-1.0)*r01*x1598*x1599)));
evalcond[4]=((((-1.0)*x1604))+((r12*x1607))+((x1603*x1609))+(((-1.0)*r11*x1598*x1599)));
evalcond[5]=(x1609+x1608+(((-1.0)*x1600*x1602))+((cj1*r11*x1599))+(((-1.0)*x1603*x1604))+((x1605*x1606))+(((-1.0)*r01*sj1*x1599)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1612 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1612)==0){
continue;
}
IkReal x1610=pow(x1612,-0.5);
IkReal x1611=((1.0)*x1610);
CheckValue<IkReal> x1613 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1613.valid){
continue;
}
IkReal gconst51=((3.14159265358979)+(((-1.0)*(x1613.value))));
IkReal gconst52=(r10*x1611);
IkReal gconst53=(r11*x1611);
CheckValue<IkReal> x1614 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1614.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6+(x1614.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1615=(cj1*r12);
IkReal x1616=((0.4)*r22);
IkReal x1617=(r02*sj1);
CheckValue<IkReal> x1618=IKPowWithIntegerCheck(((((-0.4)*gconst52*r21))+(((0.4)*gconst53*r20))),-1);
if(!x1618.valid){
continue;
}
if( IKabs(((x1618.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1616*x1617))+(((-1.0)*x1615*x1616)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1617))+x1615+(((2.5)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1618.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1616*x1617))+(((-1.0)*x1615*x1616))))))+IKsqr(((((-1.0)*x1617))+x1615+(((2.5)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1618.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1616*x1617))+(((-1.0)*x1615*x1616))))), ((((-1.0)*x1617))+x1615+(((2.5)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1619=IKcos(j5);
IkReal x1620=IKsin(j5);
IkReal x1621=((0.4)*gconst53);
IkReal x1622=((0.8)*pz);
IkReal x1623=(gconst52*r11);
IkReal x1624=((1.0)*pz);
IkReal x1625=(gconst52*r01);
IkReal x1626=((0.4)*cj1);
IkReal x1627=(gconst52*r21);
IkReal x1628=((0.4)*sj1);
IkReal x1629=(r20*x1620);
IkReal x1630=((0.4)*x1619);
IkReal x1631=((0.4)*x1620);
evalcond[0]=((((-1.0)*r12*x1626))+((r02*x1628))+x1630+(((-1.0)*r22*x1624)));
evalcond[1]=((((-1.0)*x1624))+((r22*x1630))+((x1621*x1629))+(((-1.0)*x1627*x1631)));
evalcond[2]=(((r22*x1619*x1622))+((gconst53*x1622*x1629))+(((-1.0)*x1620*x1622*x1627)));
evalcond[3]=(((r02*x1630))+x1628+(((-1.0)*x1625*x1631))+((r00*x1620*x1621)));
evalcond[4]=((((-1.0)*x1623*x1631))+((r12*x1630))+(((-1.0)*x1626))+((r10*x1620*x1621)));
evalcond[5]=((((-1.0)*cj1*r10*x1621))+((pz*x1627))+((r00*sj1*x1621))+x1631+((x1623*x1626))+(((-1.0)*x1625*x1628))+(((-1.0)*gconst53*r20*x1624)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1634 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1634)==0){
continue;
}
IkReal x1632=pow(x1634,-0.5);
IkReal x1633=((-1.0)*x1632);
CheckValue<IkReal> x1635 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1635.valid){
continue;
}
IkReal gconst54=((-1.0)*(x1635.value));
IkReal gconst55=(r00*x1633);
IkReal gconst56=(r01*x1633);
CheckValue<IkReal> x1636 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1636.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1636.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1637=(cj1*r12);
IkReal x1638=((0.4)*r22);
IkReal x1639=(r02*sj1);
CheckValue<IkReal> x1640=IKPowWithIntegerCheck(((((0.4)*gconst56*r20))+(((-0.4)*gconst55*r21))),-1);
if(!x1640.valid){
continue;
}
if( IKabs(((x1640.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1637*x1638))+pz+((x1638*x1639)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1637+(((2.5)*pz*r22))+(((-1.0)*x1639)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1640.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1637*x1638))+pz+((x1638*x1639))))))+IKsqr((x1637+(((2.5)*pz*r22))+(((-1.0)*x1639))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1640.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1637*x1638))+pz+((x1638*x1639))))), (x1637+(((2.5)*pz*r22))+(((-1.0)*x1639))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1641=IKcos(j5);
IkReal x1642=IKsin(j5);
IkReal x1643=(gconst56*r00);
IkReal x1644=(gconst55*r01);
IkReal x1645=((0.8)*pz);
IkReal x1646=((0.4)*sj1);
IkReal x1647=(gconst55*r21);
IkReal x1648=((1.0)*pz);
IkReal x1649=((0.4)*cj1);
IkReal x1650=(gconst55*r11);
IkReal x1651=(gconst56*r20);
IkReal x1652=(gconst56*r10);
IkReal x1653=((0.4)*x1642);
IkReal x1654=((0.4)*x1641);
evalcond[0]=(((r02*x1646))+(((-1.0)*r22*x1648))+(((-1.0)*r12*x1649))+x1654);
evalcond[1]=(((r22*x1654))+(((-1.0)*x1647*x1653))+(((-1.0)*x1648))+((x1651*x1653)));
evalcond[2]=(((r22*x1641*x1645))+((x1642*x1645*x1651))+(((-1.0)*x1642*x1645*x1647)));
evalcond[3]=((((-1.0)*x1644*x1653))+((r02*x1654))+x1646+((x1643*x1653)));
evalcond[4]=(((r12*x1654))+(((-1.0)*x1650*x1653))+(((-1.0)*x1649))+((x1652*x1653)));
evalcond[5]=(((pz*x1647))+(((-1.0)*x1644*x1646))+x1653+((x1649*x1650))+(((-1.0)*x1649*x1652))+((x1643*x1646))+(((-1.0)*x1648*x1651)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1657 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1657)==0){
continue;
}
IkReal x1655=pow(x1657,-0.5);
IkReal x1656=((1.0)*x1655);
CheckValue<IkReal> x1658 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1658.valid){
continue;
}
IkReal gconst57=((3.14159265358979)+(((-1.0)*(x1658.value))));
IkReal gconst58=(r00*x1656);
IkReal gconst59=(r01*x1656);
CheckValue<IkReal> x1659 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1659.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1659.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1660=(cj1*r12);
IkReal x1661=((0.4)*r22);
IkReal x1662=(r02*sj1);
CheckValue<IkReal> x1663=IKPowWithIntegerCheck(((((0.4)*gconst59*r20))+(((-0.4)*gconst58*r21))),-1);
if(!x1663.valid){
continue;
}
if( IKabs(((x1663.value)*(((((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1660*x1661))+((x1661*x1662)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1660+(((2.5)*pz*r22))+(((-1.0)*x1662)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1663.value)*(((((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1660*x1661))+((x1661*x1662))))))+IKsqr((x1660+(((2.5)*pz*r22))+(((-1.0)*x1662))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1663.value)*(((((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1660*x1661))+((x1661*x1662))))), (x1660+(((2.5)*pz*r22))+(((-1.0)*x1662))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1664=IKcos(j5);
IkReal x1665=IKsin(j5);
IkReal x1666=((0.4)*cj1);
IkReal x1667=(gconst58*r11);
IkReal x1668=((0.8)*pz);
IkReal x1669=((1.0)*pz);
IkReal x1670=(gconst58*r21);
IkReal x1671=((0.4)*sj1);
IkReal x1672=(gconst58*r01);
IkReal x1673=(gconst59*r10);
IkReal x1674=(gconst59*r20);
IkReal x1675=((0.4)*x1664);
IkReal x1676=((0.4)*gconst59*r00);
IkReal x1677=((0.4)*x1665);
evalcond[0]=(((r02*x1671))+x1675+(((-1.0)*r12*x1666))+(((-1.0)*r22*x1669)));
evalcond[1]=(((x1674*x1677))+(((-1.0)*x1669))+(((-1.0)*x1670*x1677))+((r22*x1675)));
evalcond[2]=(((r22*x1664*x1668))+((x1665*x1668*x1674))+(((-1.0)*x1665*x1668*x1670)));
evalcond[3]=((((-1.0)*x1672*x1677))+((x1665*x1676))+((r02*x1675))+x1671);
evalcond[4]=((((-1.0)*x1667*x1677))+((x1673*x1677))+(((-1.0)*x1666))+((r12*x1675)));
evalcond[5]=(x1677+(((-1.0)*x1669*x1674))+((pz*x1670))+(((-1.0)*x1671*x1672))+((gconst59*r00*x1671))+(((-1.0)*x1666*x1673))+((x1666*x1667)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1678=((-1.0)*r21);
IkReal x1680 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1680)==0){
continue;
}
IkReal x1679=pow(x1680,-0.5);
CheckValue<IkReal> x1681 = IKatan2WithCheck(IkReal(r20),IkReal(x1678),IKFAST_ATAN2_MAGTHRESH);
if(!x1681.valid){
continue;
}
IkReal gconst60=((-1.0)*(x1681.value));
IkReal gconst61=((-1.0)*r20*x1679);
IkReal gconst62=(x1678*x1679);
CheckValue<IkReal> x1682 = IKatan2WithCheck(IkReal(r20),IkReal(((-1.0)*r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1682.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1682.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1683=(cj1*r12);
IkReal x1684=((2.0)*sj1);
IkReal x1685=(pz*r22);
CheckValue<IkReal> x1686=IKPowWithIntegerCheck(((((2.0)*gconst62*r00))+(((-2.0)*gconst61*r01))),-1);
if(!x1686.valid){
continue;
}
if( IKabs(((x1686.value)*(((((-2.0)*r02*x1683))+(((-1.0)*x1684))+((x1684*(r02*r02)))+(((-5.0)*r02*x1685)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1683+(((-1.0)*r02*sj1))+(((2.5)*x1685)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1686.value)*(((((-2.0)*r02*x1683))+(((-1.0)*x1684))+((x1684*(r02*r02)))+(((-5.0)*r02*x1685))))))+IKsqr((x1683+(((-1.0)*r02*sj1))+(((2.5)*x1685))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1686.value)*(((((-2.0)*r02*x1683))+(((-1.0)*x1684))+((x1684*(r02*r02)))+(((-5.0)*r02*x1685))))), (x1683+(((-1.0)*r02*sj1))+(((2.5)*x1685))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1687=IKcos(j5);
IkReal x1688=IKsin(j5);
IkReal x1689=((0.8)*pz);
IkReal x1690=((0.4)*r10);
IkReal x1691=((0.4)*gconst61);
IkReal x1692=((1.0)*pz);
IkReal x1693=(gconst61*r21);
IkReal x1694=((0.4)*cj1);
IkReal x1695=((0.4)*r00);
IkReal x1696=((0.4)*sj1);
IkReal x1697=(gconst62*x1688);
IkReal x1698=((0.4)*x1687);
IkReal x1699=(x1688*x1691);
evalcond[0]=((((-1.0)*r12*x1694))+x1698+((r02*x1696))+(((-1.0)*r22*x1692)));
evalcond[1]=((((-1.0)*r21*x1699))+(((-1.0)*x1692))+(((0.4)*r20*x1697))+((r22*x1698)));
evalcond[2]=((((-1.0)*x1688*x1689*x1693))+((r22*x1687*x1689))+((r20*x1689*x1697)));
evalcond[3]=(x1696+((x1695*x1697))+((r02*x1698))+(((-1.0)*r01*x1699)));
evalcond[4]=(((r12*x1698))+((x1690*x1697))+(((-1.0)*x1694))+(((-1.0)*r11*x1699)));
evalcond[5]=(((cj1*r11*x1691))+(((-1.0)*cj1*gconst62*x1690))+(((0.4)*x1688))+(((-1.0)*gconst62*r20*x1692))+((pz*x1693))+(((-1.0)*r01*sj1*x1691))+((gconst62*sj1*x1695)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1702 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1702)==0){
continue;
}
IkReal x1700=pow(x1702,-0.5);
IkReal x1701=((1.0)*x1700);
CheckValue<IkReal> x1703 = IKatan2WithCheck(IkReal(r20),IkReal(((-1.0)*r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1703.valid){
continue;
}
IkReal gconst63=((3.14159265358979)+(((-1.0)*(x1703.value))));
IkReal gconst64=(r20*x1701);
IkReal gconst65=(r21*x1701);
CheckValue<IkReal> x1704 = IKatan2WithCheck(IkReal(r20),IkReal(((-1.0)*r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1704.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1704.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1705=(cj1*r12);
IkReal x1706=((2.0)*sj1);
IkReal x1707=(pz*r22);
CheckValue<IkReal> x1708=IKPowWithIntegerCheck(((((-2.0)*gconst64*r01))+(((2.0)*gconst65*r00))),-1);
if(!x1708.valid){
continue;
}
if( IKabs(((x1708.value)*(((((-1.0)*x1706))+((x1706*(r02*r02)))+(((-5.0)*r02*x1707))+(((-2.0)*r02*x1705)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1705+(((-1.0)*r02*sj1))+(((2.5)*x1707)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1708.value)*(((((-1.0)*x1706))+((x1706*(r02*r02)))+(((-5.0)*r02*x1707))+(((-2.0)*r02*x1705))))))+IKsqr((x1705+(((-1.0)*r02*sj1))+(((2.5)*x1707))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1708.value)*(((((-1.0)*x1706))+((x1706*(r02*r02)))+(((-5.0)*r02*x1707))+(((-2.0)*r02*x1705))))), (x1705+(((-1.0)*r02*sj1))+(((2.5)*x1707))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1709=IKcos(j5);
IkReal x1710=IKsin(j5);
IkReal x1711=((1.0)*pz);
IkReal x1712=(gconst65*r20);
IkReal x1713=((0.8)*pz);
IkReal x1714=(gconst64*r21);
IkReal x1715=((0.4)*cj1);
IkReal x1716=(gconst64*r01);
IkReal x1717=(gconst64*r11);
IkReal x1718=(gconst65*r00);
IkReal x1719=((0.4)*sj1);
IkReal x1720=(gconst65*r10);
IkReal x1721=((0.4)*x1709);
IkReal x1722=((0.4)*x1710);
evalcond[0]=(((r02*x1719))+x1721+(((-1.0)*r22*x1711))+(((-1.0)*r12*x1715)));
evalcond[1]=((((-1.0)*x1711))+((r22*x1721))+(((-1.0)*x1714*x1722))+((x1712*x1722)));
evalcond[2]=((((-1.0)*x1710*x1713*x1714))+((r22*x1709*x1713))+((x1710*x1712*x1713)));
evalcond[3]=(x1719+((x1718*x1722))+((r02*x1721))+(((-1.0)*x1716*x1722)));
evalcond[4]=((((-1.0)*x1715))+((x1720*x1722))+(((-1.0)*x1717*x1722))+((r12*x1721)));
evalcond[5]=((((-1.0)*x1715*x1720))+x1722+(((-1.0)*x1716*x1719))+(((-1.0)*x1711*x1712))+((x1715*x1717))+((pz*x1714))+((x1718*x1719)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1723=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1723);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1723);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1724=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1724);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1724);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1725=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1725);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1725);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
j5eval[1]=r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1726=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1726.valid){
continue;
}
CheckValue<IkReal> x1727=IKPowWithIntegerCheck(r22,-1);
if(!x1727.valid){
continue;
}
if( IKabs(((-2.0)*sj1*(x1726.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.5)*pz*(x1727.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-2.0)*sj1*(x1726.value)))+IKsqr(((2.5)*pz*(x1727.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-2.0)*sj1*(x1726.value)), ((2.5)*pz*(x1727.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1728=IKcos(j5);
IkReal x1729=IKsin(j5);
IkReal x1730=((0.4)*cj6);
IkReal x1731=((1.0)*pz);
IkReal x1732=((0.4)*x1728);
IkReal x1733=((0.4)*r01*sj6);
IkReal x1734=((0.4)*r11*sj6);
evalcond[0]=((0.8)*pz*r22*x1728);
evalcond[1]=(x1732+(((-1.0)*r22*x1731)));
evalcond[2]=(((r22*x1732))+(((-1.0)*x1731)));
evalcond[3]=((((-1.0)*x1729*x1733))+((r00*x1729*x1730))+(((0.4)*sj1)));
evalcond[4]=(((r10*x1729*x1730))+(((-1.0)*x1729*x1734))+(((-0.4)*cj1)));
evalcond[5]=(((r00*sj1*x1730))+(((0.4)*x1729))+(((-1.0)*cj1*r10*x1730))+((cj1*x1734))+(((-1.0)*sj1*x1733)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1735=IKPowWithIntegerCheck(((((2.0)*cj6*r10))+(((-2.0)*r11*sj6))),-1);
if(!x1735.valid){
continue;
}
if( IKabs(((2.0)*cj1*(x1735.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.5)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((2.0)*cj1*(x1735.value)))+IKsqr(((2.5)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((2.0)*cj1*(x1735.value)), ((2.5)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1736=IKcos(j5);
IkReal x1737=IKsin(j5);
IkReal x1738=((0.4)*cj6);
IkReal x1739=((1.0)*pz);
IkReal x1740=((0.4)*x1736);
IkReal x1741=((0.4)*r01*sj6);
IkReal x1742=((0.4)*r11*sj6);
evalcond[0]=((0.8)*pz*r22*x1736);
evalcond[1]=(x1740+(((-1.0)*r22*x1739)));
evalcond[2]=(((r22*x1740))+(((-1.0)*x1739)));
evalcond[3]=(((r00*x1737*x1738))+(((0.4)*sj1))+(((-1.0)*x1737*x1741)));
evalcond[4]=((((-1.0)*x1737*x1742))+((r10*x1737*x1738))+(((-0.4)*cj1)));
evalcond[5]=(((r00*sj1*x1738))+(((0.4)*x1737))+(((-1.0)*cj1*r10*x1738))+((cj1*x1742))+(((-1.0)*sj1*x1741)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1743=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1743.valid){
continue;
}
if( IKabs(((-2.0)*sj1*(x1743.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.5)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-2.0)*sj1*(x1743.value)))+IKsqr(((2.5)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-2.0)*sj1*(x1743.value)), ((2.5)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1744=IKcos(j5);
IkReal x1745=IKsin(j5);
IkReal x1746=((0.4)*cj6);
IkReal x1747=((1.0)*pz);
IkReal x1748=((0.4)*x1744);
IkReal x1749=((0.4)*r01*sj6);
IkReal x1750=((0.4)*r11*sj6);
evalcond[0]=((0.8)*pz*r22*x1744);
evalcond[1]=(x1748+(((-1.0)*r22*x1747)));
evalcond[2]=(((r22*x1748))+(((-1.0)*x1747)));
evalcond[3]=((((-1.0)*x1745*x1749))+(((0.4)*sj1))+((r00*x1745*x1746)));
evalcond[4]=((((-1.0)*x1745*x1750))+((r10*x1745*x1746))+(((-0.4)*cj1)));
evalcond[5]=((((-1.0)*cj1*r10*x1746))+((cj1*x1750))+(((-1.0)*sj1*x1749))+(((0.4)*x1745))+((r00*sj1*x1746)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1751=((2.0)*cj1);
IkReal x1752=(r02*sj1);
IkReal x1753=(pz*r22);
CheckValue<IkReal> x1754=IKPowWithIntegerCheck(((((2.0)*cj6*r10))+(((-2.0)*r11*sj6))),-1);
if(!x1754.valid){
continue;
}
if( IKabs(((x1754.value)*((x1751+(((-5.0)*r12*x1753))+(((2.0)*r12*x1752))+(((-1.0)*x1751*(r12*r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((2.5)*x1753))+((cj1*r12))+(((-1.0)*x1752)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1754.value)*((x1751+(((-5.0)*r12*x1753))+(((2.0)*r12*x1752))+(((-1.0)*x1751*(r12*r12)))))))+IKsqr(((((2.5)*x1753))+((cj1*r12))+(((-1.0)*x1752))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1754.value)*((x1751+(((-5.0)*r12*x1753))+(((2.0)*r12*x1752))+(((-1.0)*x1751*(r12*r12)))))), ((((2.5)*x1753))+((cj1*r12))+(((-1.0)*x1752))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1755=IKcos(j5);
IkReal x1756=IKsin(j5);
IkReal x1757=((0.4)*cj6);
IkReal x1758=((0.4)*sj6);
IkReal x1759=(pz*r22);
IkReal x1760=((1.0)*pz);
IkReal x1761=(cj6*r20);
IkReal x1762=((0.4)*cj1);
IkReal x1763=((0.4)*sj1);
IkReal x1764=((0.4)*x1755);
IkReal x1765=(pz*r21*sj6);
IkReal x1766=((0.8)*x1756);
evalcond[0]=(x1764+(((-1.0)*r12*x1762))+(((-1.0)*x1759))+((r02*x1763)));
evalcond[1]=((((-1.0)*x1760))+((r20*x1756*x1757))+(((-1.0)*r21*x1756*x1758))+((r22*x1764)));
evalcond[2]=((((0.8)*x1755*x1759))+(((-1.0)*x1765*x1766))+((pz*x1761*x1766)));
evalcond[3]=((((-1.0)*r01*x1756*x1758))+x1763+((r00*x1756*x1757))+((r02*x1764)));
evalcond[4]=((((-1.0)*x1762))+((r10*x1756*x1757))+((r12*x1764))+(((-1.0)*r11*x1756*x1758)));
evalcond[5]=((((-1.0)*cj1*r10*x1757))+x1765+((cj1*r11*x1758))+(((-1.0)*r01*sj1*x1758))+(((-1.0)*x1760*x1761))+(((0.4)*x1756))+((r00*sj1*x1757)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1767=(cj1*r12);
IkReal x1768=((2.0)*sj1);
IkReal x1769=(pz*r22);
CheckValue<IkReal> x1770=IKPowWithIntegerCheck(((((2.0)*cj6*r00))+(((-2.0)*r01*sj6))),-1);
if(!x1770.valid){
continue;
}
if( IKabs(((x1770.value)*(((((-5.0)*r02*x1769))+(((-1.0)*x1768))+((x1768*(r02*r02)))+(((-2.0)*r02*x1767)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1767+(((-1.0)*r02*sj1))+(((2.5)*x1769)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1770.value)*(((((-5.0)*r02*x1769))+(((-1.0)*x1768))+((x1768*(r02*r02)))+(((-2.0)*r02*x1767))))))+IKsqr((x1767+(((-1.0)*r02*sj1))+(((2.5)*x1769))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1770.value)*(((((-5.0)*r02*x1769))+(((-1.0)*x1768))+((x1768*(r02*r02)))+(((-2.0)*r02*x1767))))), (x1767+(((-1.0)*r02*sj1))+(((2.5)*x1769))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1771=IKcos(j5);
IkReal x1772=IKsin(j5);
IkReal x1773=((0.4)*cj6);
IkReal x1774=((0.4)*sj6);
IkReal x1775=(pz*r22);
IkReal x1776=((1.0)*pz);
IkReal x1777=(cj6*r20);
IkReal x1778=((0.4)*cj1);
IkReal x1779=((0.4)*sj1);
IkReal x1780=((0.4)*x1771);
IkReal x1781=(pz*r21*sj6);
IkReal x1782=((0.8)*x1772);
evalcond[0]=((((-1.0)*x1775))+x1780+((r02*x1779))+(((-1.0)*r12*x1778)));
evalcond[1]=(((r20*x1772*x1773))+(((-1.0)*r21*x1772*x1774))+((r22*x1780))+(((-1.0)*x1776)));
evalcond[2]=(((pz*x1777*x1782))+(((0.8)*x1771*x1775))+(((-1.0)*x1781*x1782)));
evalcond[3]=((((-1.0)*r01*x1772*x1774))+((r00*x1772*x1773))+x1779+((r02*x1780)));
evalcond[4]=(((r10*x1772*x1773))+(((-1.0)*x1778))+((r12*x1780))+(((-1.0)*r11*x1772*x1774)));
evalcond[5]=((((0.4)*x1772))+x1781+(((-1.0)*r01*sj1*x1774))+((r00*sj1*x1773))+(((-1.0)*x1776*x1777))+(((-1.0)*cj1*r10*x1773))+((cj1*r11*x1774)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1783=(cj1*r12);
IkReal x1784=((0.4)*r22);
IkReal x1785=(r02*sj1);
CheckValue<IkReal> x1786=IKPowWithIntegerCheck(((((0.4)*cj6*r20))+(((-0.4)*r21*sj6))),-1);
if(!x1786.valid){
continue;
}
if( IKabs(((x1786.value)*(((((-1.0)*x1783*x1784))+(((-1.0)*pz*(r22*r22)))+((x1784*x1785))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1783+(((2.5)*pz*r22))+(((-1.0)*x1785)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1786.value)*(((((-1.0)*x1783*x1784))+(((-1.0)*pz*(r22*r22)))+((x1784*x1785))+pz))))+IKsqr((x1783+(((2.5)*pz*r22))+(((-1.0)*x1785))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1786.value)*(((((-1.0)*x1783*x1784))+(((-1.0)*pz*(r22*r22)))+((x1784*x1785))+pz))), (x1783+(((2.5)*pz*r22))+(((-1.0)*x1785))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1787=IKcos(j5);
IkReal x1788=IKsin(j5);
IkReal x1789=((0.4)*cj6);
IkReal x1790=((0.4)*sj6);
IkReal x1791=(pz*r22);
IkReal x1792=((1.0)*pz);
IkReal x1793=(cj6*r20);
IkReal x1794=((0.4)*cj1);
IkReal x1795=((0.4)*sj1);
IkReal x1796=((0.4)*x1787);
IkReal x1797=(pz*r21*sj6);
IkReal x1798=((0.8)*x1788);
evalcond[0]=(x1796+(((-1.0)*r12*x1794))+((r02*x1795))+(((-1.0)*x1791)));
evalcond[1]=((((-1.0)*x1792))+(((-1.0)*r21*x1788*x1790))+((r22*x1796))+((r20*x1788*x1789)));
evalcond[2]=((((0.8)*x1787*x1791))+((pz*x1793*x1798))+(((-1.0)*x1797*x1798)));
evalcond[3]=(((r00*x1788*x1789))+x1795+(((-1.0)*r01*x1788*x1790))+((r02*x1796)));
evalcond[4]=((((-1.0)*r11*x1788*x1790))+(((-1.0)*x1794))+((r10*x1788*x1789))+((r12*x1796)));
evalcond[5]=((((-1.0)*x1792*x1793))+x1797+(((-1.0)*cj1*r10*x1789))+((cj1*r11*x1790))+(((0.4)*x1788))+((r00*sj1*x1789))+(((-1.0)*r01*sj1*x1790)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1799=((((0.4)*cj6*r20))+(((-0.4)*r21*sj6)));
CheckValue<IkReal> x1802 = IKatan2WithCheck(IkReal(((0.4)*r22)),IkReal(x1799),IKFAST_ATAN2_MAGTHRESH);
if(!x1802.valid){
continue;
}
IkReal x1800=((1.0)*(x1802.value));
if((((((0.16)*(r22*r22)))+(x1799*x1799))) < -0.00001)
continue;
CheckValue<IkReal> x1803=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.16)*(r22*r22)))+(x1799*x1799)))),-1);
if(!x1803.valid){
continue;
}
if( ((pz*(x1803.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1803.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1801=IKasin((pz*(x1803.value)));
j5array[0]=((((-1.0)*x1800))+x1801);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1800))+(((-1.0)*x1801)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1804=IKsin(j5);
IkReal x1805=((0.8)*pz);
evalcond[0]=(((cj6*r20*x1804*x1805))+((r22*x1805*(IKcos(j5))))+(((-1.0)*r21*sj6*x1804*x1805)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1806=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj5*r02))+(((-1.0)*cj6*r00*x1806)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r12))+(((-1.0)*r11*sj6*x1806))+((cj6*r10*sj5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj5*r02))+(((-1.0)*cj6*r00*x1806))))+IKsqr((((cj5*r12))+(((-1.0)*r11*sj6*x1806))+((cj6*r10*sj5))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj5*r02))+(((-1.0)*cj6*r00*x1806))), (((cj5*r12))+(((-1.0)*r11*sj6*x1806))+((cj6*r10*sj5))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1807=IKsin(j1);
IkReal x1808=IKcos(j1);
IkReal x1809=((0.4)*sj5);
IkReal x1810=(r11*sj6);
IkReal x1811=(pz*sj6);
IkReal x1812=((1.0)*r20);
IkReal x1813=(cj6*r00);
IkReal x1814=(cj6*pz);
IkReal x1815=(cj6*r10);
IkReal x1816=((0.4)*cj5);
IkReal x1817=(r01*sj6);
IkReal x1818=((0.4)*x1808);
IkReal x1819=((0.4)*x1807);
evalcond[0]=(((r02*x1819))+(((-1.0)*pz*r22))+(((-1.0)*r12*x1818))+x1816);
evalcond[1]=(((r02*x1816))+(((-1.0)*x1809*x1817))+((x1809*x1813))+x1819);
evalcond[2]=((((-1.0)*x1818))+(((-1.0)*x1809*x1810))+((x1809*x1815))+((r12*x1816)));
evalcond[3]=((((-1.0)*x1811*x1812))+((cj6*r01*x1819))+(((-1.0)*cj6*r11*x1818))+((r00*sj6*x1819))+(((-1.0)*r21*x1814))+(((-1.0)*r10*sj6*x1818)));
evalcond[4]=((((-1.0)*x1812*x1814))+((x1813*x1819))+x1809+(((-1.0)*x1815*x1818))+((r21*x1811))+((x1810*x1818))+(((-1.0)*x1817*x1819)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1820=((0.8)*pz);
CheckValue<IkReal> x1822 = IKatan2WithCheck(IkReal((r22*x1820)),IkReal((((cj6*r20*x1820))+(((-1.0)*r21*sj6*x1820)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1822.valid){
continue;
}
IkReal x1821=x1822.value;
j5array[0]=((-1.0)*x1821);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1821)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1823=IKsin(j5);
IkReal x1824=((0.4)*x1823);
evalcond[0]=(((cj6*r20*x1824))+(((0.4)*r22*(IKcos(j5))))+(((-1.0)*pz))+(((-1.0)*r21*sj6*x1824)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1825=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1825))+(((-1.0)*cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1825)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1825))+(((-1.0)*cj5*r02))))+IKsqr((((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1825))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1825))+(((-1.0)*cj5*r02))), (((cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1825))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1826=IKsin(j1);
IkReal x1827=IKcos(j1);
IkReal x1828=((0.4)*sj5);
IkReal x1829=(r11*sj6);
IkReal x1830=(pz*sj6);
IkReal x1831=((1.0)*r20);
IkReal x1832=(cj6*r00);
IkReal x1833=(cj6*pz);
IkReal x1834=(cj6*r10);
IkReal x1835=((0.4)*cj5);
IkReal x1836=(r01*sj6);
IkReal x1837=((0.4)*x1827);
IkReal x1838=((0.4)*x1826);
evalcond[0]=((((-1.0)*pz*r22))+((r02*x1838))+x1835+(((-1.0)*r12*x1837)));
evalcond[1]=((((-1.0)*x1828*x1836))+((r02*x1835))+x1838+((x1828*x1832)));
evalcond[2]=((((-1.0)*x1837))+(((-1.0)*x1828*x1829))+((r12*x1835))+((x1828*x1834)));
evalcond[3]=((((-1.0)*r10*sj6*x1837))+((r00*sj6*x1838))+((cj6*r01*x1838))+(((-1.0)*cj6*r11*x1837))+(((-1.0)*r21*x1833))+(((-1.0)*x1830*x1831)));
evalcond[4]=((((-1.0)*x1834*x1837))+(((-1.0)*x1836*x1838))+((x1829*x1837))+((r21*x1830))+x1828+((x1832*x1838))+(((-1.0)*x1831*x1833)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1841 = IKatan2WithCheck(IkReal(((0.8)*py)),IkReal(((-0.8)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1841.valid){
continue;
}
IkReal x1839=((1.0)*(x1841.value));
if((((((0.64)*(px*px)))+(((0.64)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1842=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.64)*(px*px)))+(((0.64)*(py*py)))))),-1);
if(!x1842.valid){
continue;
}
if( ((pp*(x1842.value))) < -1-IKFAST_SINCOS_THRESH || ((pp*(x1842.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1840=IKasin((pp*(x1842.value)));
j1array[0]=((((-1.0)*x1839))+(((-1.0)*x1840)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1839))+x1840);
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=((((2.5)*npz))+((cj1*r12))+(((-1.0)*r02*sj1)));
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j6eval[3];
IkReal x1843=(r02*sj5);
IkReal x1844=((2.0)*cj1);
IkReal x1845=((2.0)*cj5);
j6eval[0]=x1843;
j6eval[1]=IKsign(x1843);
j6eval[2]=((IKabs(((((-5.0)*rxp1_0))+((r00*x1845))+((r21*x1844)))))+(IKabs(((((-1.0)*r01*x1845))+((r20*x1844))+(((-5.0)*rxp0_0))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1846=(r12*sj5);
IkReal x1847=((2.0)*cj5);
IkReal x1848=((2.0)*sj1);
j6eval[0]=x1846;
j6eval[1]=((IKabs(((((5.0)*rxp0_1))+(((-1.0)*r20*x1848))+((r11*x1847)))))+(IKabs(((((-1.0)*r10*x1847))+(((5.0)*rxp1_1))+(((-1.0)*r21*x1848))))));
j6eval[2]=IKsign(x1846);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1849=((5.0)*pp);
IkReal x1850=((4.0)*cj5);
IkReal x1851=((10.0)*pz);
IkReal x1852=(npx*r21*sj5);
IkReal x1853=(npy*r20*sj5);
j6eval[0]=((((-1.0)*x1852))+x1853);
j6eval[1]=IKsign(((((4.0)*x1853))+(((-4.0)*x1852))));
j6eval[2]=((IKabs((((npy*x1851))+((npz*r21*x1850))+(((-1.0)*r21*x1849))+(((-1.0)*npy*r22*x1850)))))+(IKabs((((npx*x1851))+(((-1.0)*r20*x1849))+((npz*r20*x1850))+(((-1.0)*npx*r22*x1850))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1854=((0.4)*cj1);
IkReal x1855=((0.4)*sj1);
j6eval[0]=((IKabs(((((-1.0)*npx))+((r00*x1855))+(((-1.0)*r10*x1854)))))+(IKabs((npy+(((-1.0)*r01*x1855))+((r11*x1854))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1856=((0.4)*sj1);
IkReal x1857=((0.4)*cj1);
j6eval[0]=((IKabs((((r01*x1856))+(((-1.0)*npy))+(((-1.0)*r11*x1857)))))+(IKabs(((((-1.0)*npx))+((r00*x1856))+(((-1.0)*r10*x1857))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1858=((0.4)*sj1);
IkReal x1859=((0.4)*cj1);
CheckValue<IkReal> x1861 = IKatan2WithCheck(IkReal((((r01*x1858))+(((-1.0)*npy))+(((-1.0)*r11*x1859)))),IkReal(((((-1.0)*npx))+((r00*x1858))+(((-1.0)*r10*x1859)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1861.valid){
continue;
}
IkReal x1860=x1861.value;
j6array[0]=((-1.0)*x1860);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1860)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1862=IKsin(j6);
IkReal x1863=IKcos(j6);
IkReal x1864=((0.4)*x1863);
IkReal x1865=((0.4)*x1862);
evalcond[0]=((((-1.0)*r01*sj1*x1865))+((cj1*r11*x1865))+(((-1.0)*cj1*r10*x1864))+(((-1.0)*npx*x1863))+((r00*sj1*x1864))+((npy*x1862)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1866=((0.4)*sj1);
IkReal x1867=((0.4)*cj1);
CheckValue<IkReal> x1869 = IKatan2WithCheck(IkReal(((((-1.0)*npx))+((r00*x1866))+(((-1.0)*r10*x1867)))),IkReal((((r11*x1867))+npy+(((-1.0)*r01*x1866)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1869.valid){
continue;
}
IkReal x1868=x1869.value;
j6array[0]=((-1.0)*x1868);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1868)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1870=IKcos(j6);
IkReal x1871=IKsin(j6);
IkReal x1872=((0.4)*sj1);
IkReal x1873=((0.4)*cj1);
evalcond[0]=(((r01*x1870*x1872))+(((-1.0)*r10*x1871*x1873))+((r00*x1871*x1872))+(((-1.0)*r11*x1870*x1873))+(((-1.0)*npx*x1871))+(((-1.0)*npy*x1870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1874=((0.4)*cj1);
IkReal x1875=((0.4)*sj1);
j6eval[0]=((IKabs(((((-1.0)*r01*x1875))+npy+((r11*x1874)))))+(IKabs(((((-1.0)*r10*x1874))+(((-1.0)*npx))+((r00*x1875))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1876=((0.4)*sj1);
IkReal x1877=((0.4)*cj1);
j6eval[0]=((IKabs(((((-1.0)*npy))+((r01*x1876))+(((-1.0)*r11*x1877)))))+(IKabs(((((-1.0)*r10*x1877))+(((-1.0)*npx))+((r00*x1876))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1878=((0.4)*sj1);
IkReal x1879=((0.4)*cj1);
CheckValue<IkReal> x1881 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+((r01*x1878))+(((-1.0)*r11*x1879)))),IkReal(((((-1.0)*r10*x1879))+(((-1.0)*npx))+((r00*x1878)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1881.valid){
continue;
}
IkReal x1880=x1881.value;
j6array[0]=((-1.0)*x1880);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1880)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1882=IKsin(j6);
IkReal x1883=IKcos(j6);
IkReal x1884=((0.4)*x1883);
IkReal x1885=((0.4)*x1882);
evalcond[0]=(((r00*sj1*x1884))+(((-1.0)*npx*x1883))+(((-1.0)*r01*sj1*x1885))+(((-1.0)*cj1*r10*x1884))+((npy*x1882))+((cj1*r11*x1885)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1886=((0.4)*sj1);
IkReal x1887=((0.4)*cj1);
CheckValue<IkReal> x1889 = IKatan2WithCheck(IkReal(((((-1.0)*npx))+((r00*x1886))+(((-1.0)*r10*x1887)))),IkReal((npy+(((-1.0)*r01*x1886))+((r11*x1887)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1889.valid){
continue;
}
IkReal x1888=x1889.value;
j6array[0]=((-1.0)*x1888);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1888)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1890=IKcos(j6);
IkReal x1891=IKsin(j6);
IkReal x1892=((0.4)*sj1);
IkReal x1893=((0.4)*cj1);
evalcond[0]=(((r01*x1890*x1892))+(((-1.0)*npx*x1891))+(((-1.0)*r11*x1890*x1893))+(((-1.0)*r10*x1891*x1893))+((r00*x1891*x1892))+(((-1.0)*npy*x1890)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r02);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1894=(r12*sj5);
IkReal x1895=((2.0)*sj1);
IkReal x1896=((2.0)*cj5*r22);
j6eval[0]=x1894;
j6eval[1]=((IKabs((((r01*x1896))+(((5.0)*rxp1_1))+(((-1.0)*r21*x1895)))))+(IKabs((((r00*x1896))+(((-1.0)*r20*x1895))+(((5.0)*rxp0_1))))));
j6eval[2]=IKsign(x1894);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1897=(r22*sj5);
IkReal x1898=((2.0)*r00);
IkReal x1899=(cj5*r12);
IkReal x1900=((2.0)*sj1);
IkReal x1901=((2.0)*r01);
j6eval[0]=x1897;
j6eval[1]=IKsign(x1897);
j6eval[2]=((IKabs(((((-1.0)*cj1*x1898))+(((-1.0)*r10*x1900))+((x1898*x1899))+(((-5.0)*rxp0_2)))))+(IKabs(((((-5.0)*rxp1_2))+(((-1.0)*cj1*x1901))+(((-1.0)*r11*x1900))+((x1899*x1901))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1902=((0.4)*cj1);
j6eval[0]=((IKabs(((((-1.0)*px*r01))+npy+((r11*x1902)))))+(IKabs((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1902))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1903=((0.4)*cj1);
j6eval[0]=((IKabs((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1903)))))+(IKabs((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1903))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1904=((0.4)*cj1);
CheckValue<IkReal> x1906 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1904)))),IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1904)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1906.valid){
continue;
}
IkReal x1905=x1906.value;
j6array[0]=((-1.0)*x1905);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1905)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1907=IKsin(j6);
IkReal x1908=IKcos(j6);
IkReal x1909=((0.4)*cj1);
evalcond[0]=(((px*r00*x1908))+(((-1.0)*px*r01*x1907))+(((-1.0)*npx*x1908))+((r11*x1907*x1909))+(((-1.0)*r10*x1908*x1909))+((npy*x1907)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1910=((0.4)*cj1);
CheckValue<IkReal> x1912 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1910)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1910)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1912.valid){
continue;
}
IkReal x1911=x1912.value;
j6array[0]=((-1.0)*x1911);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1911)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1913=IKcos(j6);
IkReal x1914=IKsin(j6);
IkReal x1915=((0.4)*cj1);
evalcond[0]=((((-1.0)*r11*x1913*x1915))+(((-1.0)*npy*x1913))+((px*r00*x1914))+(((-1.0)*npx*x1914))+((px*r01*x1913))+(((-1.0)*r10*x1914*x1915)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1916=((0.4)*cj1);
j6eval[0]=((IKabs(((((-1.0)*px*r01))+npy+((r11*x1916)))))+(IKabs((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1916))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1917=((0.4)*cj1);
j6eval[0]=((IKabs((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1917)))))+(IKabs((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1917))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1918=((0.4)*cj1);
CheckValue<IkReal> x1920 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1918)))),IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1918)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1920.valid){
continue;
}
IkReal x1919=x1920.value;
j6array[0]=((-1.0)*x1919);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1919)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1921=IKsin(j6);
IkReal x1922=IKcos(j6);
IkReal x1923=((0.4)*cj1);
evalcond[0]=(((npy*x1921))+(((-1.0)*r10*x1922*x1923))+((r11*x1921*x1923))+(((-1.0)*npx*x1922))+(((-1.0)*px*r01*x1921))+((px*r00*x1922)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1924=((0.4)*cj1);
CheckValue<IkReal> x1926 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1924)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1924)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1926.valid){
continue;
}
IkReal x1925=x1926.value;
j6array[0]=((-1.0)*x1925);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1925)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1927=IKcos(j6);
IkReal x1928=IKsin(j6);
IkReal x1929=((0.4)*cj1);
evalcond[0]=((((-1.0)*r10*x1928*x1929))+(((-1.0)*r11*x1927*x1929))+(((-1.0)*npx*x1928))+((px*r01*x1927))+(((-1.0)*npy*x1927))+((px*r00*x1928)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r12);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
IkReal x1930=(r22*sj5);
IkReal x1931=((2.0)*sj1);
IkReal x1932=((2.0)*cj1);
j6eval[0]=x1930;
j6eval[1]=((IKabs(((((-1.0)*r01*x1932))+(((-5.0)*rxp1_2))+(((-1.0)*r11*x1931)))))+(IKabs(((((-1.0)*r10*x1931))+(((-5.0)*rxp0_2))+(((-1.0)*r00*x1932))))));
j6eval[2]=IKsign(x1930);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj5=0;
cj5=1.0;
j5=0;
j6eval[0]=((((6.25)*(npy*npy)))+(((6.25)*(npx*npx)))+(((5.0)*cj1*py))+(cj1*cj1)+(((-6.25)*(px*px))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1933=((0.4)*cj1);
CheckValue<IkReal> x1935 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1933)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1933)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1935.valid){
continue;
}
IkReal x1934=x1935.value;
j6array[0]=((-1.0)*x1934);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1934)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1936=IKcos(j6);
IkReal x1937=IKsin(j6);
IkReal x1938=((0.4)*cj1);
evalcond[0]=((((-1.0)*npy*x1936))+((px*r00*x1937))+(((-1.0)*r11*x1936*x1938))+(((-1.0)*npx*x1937))+((px*r01*x1936))+(((-1.0)*r10*x1937*x1938)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j6eval[0]=((((6.25)*(npy*npy)))+(((6.25)*(npx*npx)))+(((5.0)*cj1*py))+(cj1*cj1)+(((-6.25)*(px*px))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1939=((0.4)*cj1);
CheckValue<IkReal> x1941 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1939)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1939)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1941.valid){
continue;
}
IkReal x1940=x1941.value;
j6array[0]=((-1.0)*x1940);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1940)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1942=IKcos(j6);
IkReal x1943=IKsin(j6);
IkReal x1944=((0.4)*cj1);
evalcond[0]=(((px*r01*x1942))+(((-1.0)*npy*x1942))+((px*r00*x1943))+(((-1.0)*r11*x1942*x1944))+(((-1.0)*r10*x1943*x1944))+(((-1.0)*npx*x1943)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1945=((2.0)*sj1);
IkReal x1946=((2.0)*cj1);
CheckValue<IkReal> x1947=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1947.valid){
continue;
}
CheckValue<IkReal> x1948 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x1946))+(((-1.0)*r10*x1945))+(((-5.0)*rxp0_2)))),IkReal(((((-5.0)*rxp1_2))+(((-1.0)*r01*x1946))+(((-1.0)*r11*x1945)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1948.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1947.value)))+(x1948.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1949=IKcos(j6);
IkReal x1950=IKsin(j6);
IkReal x1951=(r01*sj1);
IkReal x1952=(cj1*r10);
IkReal x1953=((0.8)*sj5);
IkReal x1954=((1.0)*npx);
IkReal x1955=(cj1*r11);
IkReal x1956=(r00*sj1);
IkReal x1957=((0.4)*x1949);
IkReal x1958=(npy*x1950);
IkReal x1959=((0.4)*x1950);
evalcond[0]=((((-1.0)*px))+(((0.4)*sj1))+((r00*sj5*x1957))+(((-1.0)*r01*sj5*x1959)));
evalcond[1]=(((r10*sj5*x1957))+(((-1.0)*r11*sj5*x1959))+(((-1.0)*py))+(((-0.4)*cj1)));
evalcond[2]=((((-1.0)*r21*sj5*x1959))+((r20*sj5*x1957))+(((-1.0)*pz))+((pz*(r22*r22))));
evalcond[3]=(((npx*x1949*x1953))+(((0.8)*cj5*pz*r22))+(((-1.0)*pp))+(((-1.0)*x1953*x1958)));
evalcond[4]=((((-1.0)*x1952*x1959))+(((-1.0)*x1950*x1954))+(((-1.0)*npy*x1949))+((x1951*x1957))+(((-1.0)*x1955*x1957))+((x1956*x1959)));
evalcond[5]=((((-1.0)*x1949*x1954))+(((-1.0)*x1952*x1957))+((x1955*x1959))+(((-1.0)*x1951*x1959))+x1958+(((0.4)*sj5))+((x1956*x1957)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1960=((2.0)*r00);
IkReal x1961=(cj5*r12);
IkReal x1962=((2.0)*sj1);
IkReal x1963=((2.0)*r01);
CheckValue<IkReal> x1964=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1964.valid){
continue;
}
CheckValue<IkReal> x1965 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1962))+((x1960*x1961))+(((-1.0)*cj1*x1960))+(((-5.0)*rxp0_2)))),IkReal(((((-5.0)*rxp1_2))+((x1961*x1963))+(((-1.0)*cj1*x1963))+(((-1.0)*r11*x1962)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1965.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1964.value)))+(x1965.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1966=IKcos(j6);
IkReal x1967=IKsin(j6);
IkReal x1968=(r01*sj1);
IkReal x1969=(cj1*r10);
IkReal x1970=((0.8)*sj5);
IkReal x1971=((1.0)*npx);
IkReal x1972=(cj1*r11);
IkReal x1973=(cj5*r22);
IkReal x1974=(cj5*r12);
IkReal x1975=(r00*sj1);
IkReal x1976=((0.4)*x1966);
IkReal x1977=(npy*x1967);
IkReal x1978=((0.4)*x1967);
evalcond[0]=((((-1.0)*px))+((r00*sj5*x1976))+(((0.4)*sj1))+(((-1.0)*r01*sj5*x1978)));
evalcond[1]=((((-1.0)*r21*sj5*x1978))+((r20*sj5*x1976))+(((-1.0)*pz))+(((0.4)*x1973)));
evalcond[2]=(((r10*sj5*x1976))+(((-1.0)*py))+(((-1.0)*r11*sj5*x1978))+(((-0.4)*cj1))+(((0.4)*x1974)));
evalcond[3]=((((0.8)*pz*x1973))+(((0.8)*py*x1974))+(((-1.0)*pp))+(((-1.0)*x1970*x1977))+((npx*x1966*x1970)));
evalcond[4]=((((-1.0)*npy*x1966))+((x1975*x1978))+(((-1.0)*x1972*x1976))+(((-1.0)*x1969*x1978))+(((-1.0)*x1967*x1971))+((x1968*x1976)));
evalcond[5]=(((x1972*x1978))+((x1975*x1976))+(((-1.0)*x1966*x1971))+(((-1.0)*x1968*x1978))+x1977+(((0.4)*sj5))+(((-1.0)*x1969*x1976)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1979=((2.0)*sj1);
IkReal x1980=((2.0)*cj5*r22);
CheckValue<IkReal> x1981=IKPowWithIntegerCheck(IKsign((r12*sj5)),-1);
if(!x1981.valid){
continue;
}
CheckValue<IkReal> x1982 = IKatan2WithCheck(IkReal((((r00*x1980))+(((5.0)*rxp0_1))+(((-1.0)*r20*x1979)))),IkReal(((((5.0)*rxp1_1))+((r01*x1980))+(((-1.0)*r21*x1979)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1982.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((-1.5707963267949)*(x1981.value)))+(x1982.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1983=IKcos(j6);
IkReal x1984=IKsin(j6);
IkReal x1985=(r01*sj1);
IkReal x1986=(cj1*r10);
IkReal x1987=((0.8)*sj5);
IkReal x1988=((1.0)*npx);
IkReal x1989=(cj1*r11);
IkReal x1990=(cj5*r22);
IkReal x1991=(cj5*r12);
IkReal x1992=(r00*sj1);
IkReal x1993=((0.4)*x1983);
IkReal x1994=(npy*x1984);
IkReal x1995=((0.4)*x1984);
evalcond[0]=(((r00*sj5*x1993))+(((-1.0)*r01*sj5*x1995))+(((-1.0)*px))+(((0.4)*sj1)));
evalcond[1]=((((-1.0)*r21*sj5*x1995))+((r20*sj5*x1993))+(((-1.0)*pz))+(((0.4)*x1990)));
evalcond[2]=(((r10*sj5*x1993))+(((-1.0)*py))+(((0.4)*x1991))+(((-1.0)*r11*sj5*x1995))+(((-0.4)*cj1)));
evalcond[3]=((((0.8)*pz*x1990))+(((0.8)*py*x1991))+(((-1.0)*pp))+(((-1.0)*x1987*x1994))+((npx*x1983*x1987)));
evalcond[4]=((((-1.0)*x1986*x1995))+(((-1.0)*npy*x1983))+(((-1.0)*x1984*x1988))+(((-1.0)*x1989*x1993))+((x1992*x1995))+((x1985*x1993)));
evalcond[5]=((((-1.0)*x1983*x1988))+(((-1.0)*x1986*x1993))+x1994+(((0.4)*sj5))+((x1989*x1995))+(((-1.0)*x1985*x1995))+((x1992*x1993)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1996=((5.0)*pp);
IkReal x1997=((4.0)*cj5);
IkReal x1998=((4.0)*sj5);
IkReal x1999=((10.0)*pz);
CheckValue<IkReal> x2000 = IKatan2WithCheck(IkReal((((npz*r20*x1997))+((npx*x1999))+(((-1.0)*npx*r22*x1997))+(((-1.0)*r20*x1996)))),IkReal(((((-1.0)*r21*x1996))+((npz*r21*x1997))+((npy*x1999))+(((-1.0)*npy*r22*x1997)))),IKFAST_ATAN2_MAGTHRESH);
if(!x2000.valid){
continue;
}
CheckValue<IkReal> x2001=IKPowWithIntegerCheck(IKsign((((npy*r20*x1998))+(((-1.0)*npx*r21*x1998)))),-1);
if(!x2001.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x2000.value)+(((1.5707963267949)*(x2001.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x2002=IKcos(j6);
IkReal x2003=IKsin(j6);
IkReal x2004=(r01*sj1);
IkReal x2005=(cj1*r10);
IkReal x2006=((0.8)*sj5);
IkReal x2007=((1.0)*npx);
IkReal x2008=(cj1*r11);
IkReal x2009=((0.4)*cj5);
IkReal x2010=(r00*sj1);
IkReal x2011=((0.4)*x2002);
IkReal x2012=(npy*x2003);
IkReal x2013=((0.4)*x2003);
evalcond[0]=(((r22*x2009))+((r20*sj5*x2011))+(((-1.0)*r21*sj5*x2013))+(((-1.0)*pz)));
evalcond[1]=((((-1.0)*x2006*x2012))+(((-1.0)*pp))+((npx*x2002*x2006))+(((0.8)*cj5*npz)));
evalcond[2]=(((r00*sj5*x2011))+((r02*x2009))+(((-1.0)*px))+(((0.4)*sj1))+(((-1.0)*r01*sj5*x2013)));
evalcond[3]=(((r10*sj5*x2011))+(((-1.0)*r11*sj5*x2013))+((r12*x2009))+(((-1.0)*py))+(((-0.4)*cj1)));
evalcond[4]=((((-1.0)*x2008*x2011))+(((-1.0)*x2003*x2007))+((x2004*x2011))+(((-1.0)*npy*x2002))+(((-1.0)*x2005*x2013))+((x2010*x2013)));
evalcond[5]=(x2012+(((-1.0)*x2002*x2007))+(((-1.0)*x2004*x2013))+(((-1.0)*x2005*x2011))+((x2010*x2011))+(((0.4)*sj5))+((x2008*x2013)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x2014=((2.0)*cj5);
IkReal x2015=((2.0)*sj1);
CheckValue<IkReal> x2016=IKPowWithIntegerCheck(IKsign((r12*sj5)),-1);
if(!x2016.valid){
continue;
}
CheckValue<IkReal> x2017 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x2015))+(((5.0)*rxp0_1))+((r11*x2014)))),IkReal(((((-1.0)*r21*x2015))+(((5.0)*rxp1_1))+(((-1.0)*r10*x2014)))),IKFAST_ATAN2_MAGTHRESH);
if(!x2017.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((-1.5707963267949)*(x2016.value)))+(x2017.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x2018=IKcos(j6);
IkReal x2019=IKsin(j6);
IkReal x2020=(r01*sj1);
IkReal x2021=(cj1*r10);
IkReal x2022=((0.8)*sj5);
IkReal x2023=((1.0)*npx);
IkReal x2024=(cj1*r11);
IkReal x2025=((0.4)*cj5);
IkReal x2026=(r00*sj1);
IkReal x2027=((0.4)*x2018);
IkReal x2028=(npy*x2019);
IkReal x2029=((0.4)*x2019);
evalcond[0]=((((-1.0)*r21*sj5*x2029))+((r22*x2025))+((r20*sj5*x2027))+(((-1.0)*pz)));
evalcond[1]=((((-1.0)*x2022*x2028))+(((-1.0)*pp))+((npx*x2018*x2022))+(((0.8)*cj5*npz)));
evalcond[2]=((((-1.0)*r01*sj5*x2029))+((r00*sj5*x2027))+(((-1.0)*px))+((r02*x2025))+(((0.4)*sj1)));
evalcond[3]=(((r10*sj5*x2027))+(((-1.0)*r11*sj5*x2029))+(((-1.0)*py))+(((-0.4)*cj1))+((r12*x2025)));
evalcond[4]=(((x2020*x2027))+(((-1.0)*x2021*x2029))+((x2026*x2029))+(((-1.0)*x2019*x2023))+(((-1.0)*x2024*x2027))+(((-1.0)*npy*x2018)));
evalcond[5]=((((-1.0)*x2021*x2027))+((x2024*x2029))+((x2026*x2027))+x2028+(((0.4)*sj5))+(((-1.0)*x2018*x2023))+(((-1.0)*x2020*x2029)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x2030=((2.0)*cj1);
IkReal x2031=((2.0)*cj5);
CheckValue<IkReal> x2032=IKPowWithIntegerCheck(IKsign((r02*sj5)),-1);
if(!x2032.valid){
continue;
}
CheckValue<IkReal> x2033 = IKatan2WithCheck(IkReal(((((-1.0)*r01*x2031))+((r20*x2030))+(((-5.0)*rxp0_0)))),IkReal(((((-5.0)*rxp1_0))+((r21*x2030))+((r00*x2031)))),IKFAST_ATAN2_MAGTHRESH);
if(!x2033.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2032.value)))+(x2033.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x2034=IKcos(j6);
IkReal x2035=IKsin(j6);
IkReal x2036=(r01*sj1);
IkReal x2037=(cj1*r10);
IkReal x2038=((0.8)*sj5);
IkReal x2039=((1.0)*npx);
IkReal x2040=(cj1*r11);
IkReal x2041=((0.4)*cj5);
IkReal x2042=(r00*sj1);
IkReal x2043=((0.4)*x2034);
IkReal x2044=(npy*x2035);
IkReal x2045=((0.4)*x2035);
evalcond[0]=(((r22*x2041))+(((-1.0)*pz))+(((-1.0)*r21*sj5*x2045))+((r20*sj5*x2043)));
evalcond[1]=(((npx*x2034*x2038))+(((-1.0)*pp))+(((0.8)*cj5*npz))+(((-1.0)*x2038*x2044)));
evalcond[2]=(((r02*x2041))+(((-1.0)*px))+(((0.4)*sj1))+((r00*sj5*x2043))+(((-1.0)*r01*sj5*x2045)));
evalcond[3]=((((-1.0)*r11*sj5*x2045))+((r12*x2041))+(((-1.0)*py))+((r10*sj5*x2043))+(((-0.4)*cj1)));
evalcond[4]=((((-1.0)*x2035*x2039))+((x2042*x2045))+(((-1.0)*npy*x2034))+(((-1.0)*x2040*x2043))+(((-1.0)*x2037*x2045))+((x2036*x2043)));
evalcond[5]=(((x2040*x2045))+((x2042*x2043))+x2044+(((0.4)*sj5))+(((-1.0)*x2036*x2045))+(((-1.0)*x2037*x2043))+(((-1.0)*x2034*x2039)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x172=((1.0)*r10);
IkReal x173=((1.0)*cj1);
IkReal x174=((1.0)*cj5);
IkReal x175=((1.0)*sj6);
IkReal x176=((1.0)*cj6);
IkReal x177=((1.0)*sj1);
IkReal x178=(((r21*sj6))+(((-1.0)*r20*x176)));
IkReal x179=((((-1.0)*r11*x173))+((r01*sj1)));
IkReal x180=(((r00*sj1))+(((-1.0)*cj1*x172)));
IkReal x181=(((r02*sj1))+(((-1.0)*r12*x173)));
IkReal x182=((1.0)*x179);
IkReal x183=((((-1.0)*r11*x177))+(((-1.0)*r01*x173)));
IkReal x184=((((-1.0)*r00*x173))+(((-1.0)*sj1*x172)));
IkReal x185=((((-1.0)*r02*x173))+(((-1.0)*r12*x177)));
IkReal x186=((((-1.0)*x175*x179))+((cj6*x180)));
IkReal x187=(((cj6*x184))+(((-1.0)*x175*x183)));
new_r00=(((sj5*x185))+(((-1.0)*x174*x187)));
new_r01=((((-1.0)*x176*x183))+(((-1.0)*x175*x184)));
new_r02=(((cj5*x185))+((sj5*x187)));
new_r10=((((-1.0)*x174*x178))+(((-1.0)*r22*sj5)));
new_r11=(((cj6*r21))+((r20*sj6)));
new_r12=((((-1.0)*r22*x174))+((sj5*x178)));
new_r20=(((sj5*x181))+(((-1.0)*x174*x186)));
new_r21=((((-1.0)*x176*x179))+(((-1.0)*x175*x180)));
new_r22=(((cj5*x181))+((sj5*x186)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=new_r22;
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=IKsign(sj3);
j4eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=new_r12;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=-1.0;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 4;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=1.0;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(new_r10, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 4;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x188=new_r22*new_r22;
IkReal x189=((16.0)*new_r10);
IkReal x190=((16.0)*new_r01);
IkReal x191=((16.0)*new_r22);
IkReal x192=((8.0)*new_r11);
IkReal x193=((8.0)*new_r00);
IkReal x194=(x188*x189);
IkReal x195=(x188*x190);
j2eval[0]=((IKabs(((((-1.0)*x195))+x190)))+(IKabs(((((-1.0)*x194))+x189)))+(IKabs((((new_r11*x191))+(((16.0)*new_r00))+(((-32.0)*new_r00*x188)))))+(IKabs((((x188*x192))+(((-1.0)*new_r22*x193)))))+(IKabs(((((32.0)*new_r11))+(((-16.0)*new_r11*x188))+(((-1.0)*new_r00*x191)))))+(IKabs(((((-1.0)*x193))+((new_r22*x192)))))+(IKabs(((((-1.0)*x190))+x195)))+(IKabs(((((-1.0)*x189))+x194))));
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2, j4]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j2evalpoly[1];
IkReal x196=new_r22*new_r22;
IkReal x197=((16.0)*new_r10);
IkReal x198=(new_r11*new_r22);
IkReal x199=(x196*x197);
IkReal x200=((((8.0)*x198))+(((-8.0)*new_r00)));
op[0]=x200;
op[1]=((((-1.0)*x199))+x197);
op[2]=((((16.0)*new_r00))+(((16.0)*x198))+(((-32.0)*new_r00*x196)));
op[3]=((((-1.0)*x197))+x199);
op[4]=x200;
polyroots4(op,zeror,numroots);
IkReal j2array[4], cj2array[4], sj2array[4], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[4]={true,true,true,true};
_nj2 = 4;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

IkReal x201=((16.0)*new_r01);
IkReal x202=new_r22*new_r22;
IkReal x203=(new_r00*new_r22);
IkReal x204=((8.0)*x203);
IkReal x205=(new_r11*x202);
IkReal x206=(x201*x202);
IkReal x207=((8.0)*x205);
j2evalpoly[0]=((((htj2*htj2*htj2)*(((((-1.0)*x201))+x206))))+(((-1.0)*x204))+(((htj2*htj2)*(((((-16.0)*x203))+(((-16.0)*x205))+(((32.0)*new_r11))))))+x207+(((htj2*htj2*htj2*htj2)*(((((-1.0)*x204))+x207))))+((htj2*(((((-1.0)*x206))+x201)))));
if( IKabs(j2evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j4eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x208=cj2*cj2;
IkReal x209=new_r22*new_r22;
IkReal x210=(new_r22*sj2);
IkReal x211=((1.0)*new_r10);
IkReal x212=((((-1.0)*x208*x209))+x209+x208);
j4eval[0]=x212;
j4eval[1]=((IKabs(((((-1.0)*x210*x211))+(((-1.0)*cj2*new_r11)))))+(IKabs(((((-1.0)*cj2*x211))+((new_r11*x210))))));
j4eval[2]=IKsign(x212);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=new_r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x213=IKsin(j4);
IkReal x214=IKcos(j4);
evalcond[0]=x213;
evalcond[1]=((-1.0)*x214);
evalcond[2]=(x213+(((-1.0)*new_r00)));
evalcond[3]=(x214+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x215=IKsin(j4);
IkReal x216=IKcos(j4);
evalcond[0]=x215;
evalcond[1]=(x215+new_r00);
evalcond[2]=(x216+new_r01);
evalcond[3]=((-1.0)*x216);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x217=new_r22*new_r22;
CheckValue<IkReal> x218=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x217))),-1);
if(!x218.valid){
continue;
}
if((((-1.0)*x217*(x218.value))) < -0.00001)
continue;
IkReal gconst78=IKsqrt(((-1.0)*x217*(x218.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst78)))))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x219=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
sj2=IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))));
cj2=gconst78;
if( (gconst78) < -1-IKFAST_SINCOS_THRESH || (gconst78) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=IKacos(gconst78);
CheckValue<IkReal> x220=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x219))),-1);
if(!x220.valid){
continue;
}
if((((-1.0)*x219*(x220.value))) < -0.00001)
continue;
IkReal gconst78=IKsqrt(((-1.0)*x219*(x220.value)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x221=IKPowWithIntegerCheck(gconst78,-1);
if(!x221.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x221.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*gconst78*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x221.value)))+IKsqr(((((-1.0)*gconst78*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78))))))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10*(x221.value)), ((((-1.0)*gconst78*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78))))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x222=IKsin(j4);
IkReal x223=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
IkReal x224=IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))));
IkReal x225=((1.0)*x224);
evalcond[0]=x222;
evalcond[1]=((-1.0)*x223);
evalcond[2]=(new_r10+((gconst78*x222)));
evalcond[3]=(new_r11+((gconst78*x223)));
evalcond[4]=((((-1.0)*x222*x225))+new_r00);
evalcond[5]=((((-1.0)*x223*x225))+new_r01);
evalcond[6]=(x222+((gconst78*new_r10))+(((-1.0)*new_r00*x225)));
evalcond[7]=((((-1.0)*new_r01*x225))+x223+((gconst78*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x226 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x226.valid){
continue;
}
CheckValue<IkReal> x227=IKPowWithIntegerCheck(IKsign(gconst78),-1);
if(!x227.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x226.value)+(((1.5707963267949)*(x227.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x228=IKsin(j4);
IkReal x229=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
IkReal x230=IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))));
IkReal x231=((1.0)*x230);
evalcond[0]=x228;
evalcond[1]=((-1.0)*x229);
evalcond[2]=(new_r10+((gconst78*x228)));
evalcond[3]=(new_r11+((gconst78*x229)));
evalcond[4]=(new_r00+(((-1.0)*x228*x231)));
evalcond[5]=(new_r01+(((-1.0)*x229*x231)));
evalcond[6]=(x228+((gconst78*new_r10))+(((-1.0)*new_r00*x231)));
evalcond[7]=(x229+((gconst78*new_r11))+(((-1.0)*new_r01*x231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x232=new_r22*new_r22;
CheckValue<IkReal> x233=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x232))),-1);
if(!x233.valid){
continue;
}
if((((-1.0)*x232*(x233.value))) < -0.00001)
continue;
IkReal gconst78=IKsqrt(((-1.0)*x232*(x233.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst78)))))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x234=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
sj2=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))))));
cj2=gconst78;
if( (gconst78) < -1-IKFAST_SINCOS_THRESH || (gconst78) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=((-1.0)*(IKacos(gconst78)));
CheckValue<IkReal> x235=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x234))),-1);
if(!x235.valid){
continue;
}
if((((-1.0)*x234*(x235.value))) < -0.00001)
continue;
IkReal gconst78=IKsqrt(((-1.0)*x234*(x235.value)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x236=IKPowWithIntegerCheck(gconst78,-1);
if(!x236.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x236.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*gconst78*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x236.value)))+IKsqr(((((-1.0)*gconst78*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78))))))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10*(x236.value)), ((((-1.0)*gconst78*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78))))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x237=IKsin(j4);
IkReal x238=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
IkReal x239=IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))));
evalcond[0]=x237;
evalcond[1]=((-1.0)*x238);
evalcond[2]=(((gconst78*x237))+new_r10);
evalcond[3]=(((gconst78*x238))+new_r11);
evalcond[4]=(((x237*x239))+new_r00);
evalcond[5]=(((x238*x239))+new_r01);
evalcond[6]=(((new_r00*x239))+x237+((gconst78*new_r10)));
evalcond[7]=(((new_r01*x239))+x238+((gconst78*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x240 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x240.valid){
continue;
}
CheckValue<IkReal> x241=IKPowWithIntegerCheck(IKsign(gconst78),-1);
if(!x241.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x240.value)+(((1.5707963267949)*(x241.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x242=IKsin(j4);
IkReal x243=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
IkReal x244=IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))));
evalcond[0]=x242;
evalcond[1]=((-1.0)*x243);
evalcond[2]=(((gconst78*x242))+new_r10);
evalcond[3]=(((gconst78*x243))+new_r11);
evalcond[4]=(((x242*x244))+new_r00);
evalcond[5]=(new_r01+((x243*x244)));
evalcond[6]=(x242+((gconst78*new_r10))+((new_r00*x244)));
evalcond[7]=(x243+((gconst78*new_r11))+((new_r01*x244)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x245=new_r22*new_r22;
CheckValue<IkReal> x246=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x245))),-1);
if(!x246.valid){
continue;
}
if((((-1.0)*x245*(x246.value))) < -0.00001)
continue;
IkReal gconst79=((-1.0)*(IKsqrt(((-1.0)*x245*(x246.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst79)))))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x247=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
sj2=IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))));
cj2=gconst79;
if( (gconst79) < -1-IKFAST_SINCOS_THRESH || (gconst79) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=IKacos(gconst79);
CheckValue<IkReal> x248=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x247))),-1);
if(!x248.valid){
continue;
}
if((((-1.0)*x247*(x248.value))) < -0.00001)
continue;
IkReal gconst79=((-1.0)*(IKsqrt(((-1.0)*x247*(x248.value)))));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x249=IKPowWithIntegerCheck(gconst79,-1);
if(!x249.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x249.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79))))))))+(((-1.0)*gconst79*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x249.value)))+IKsqr((((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79))))))))+(((-1.0)*gconst79*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10*(x249.value)), (((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79))))))))+(((-1.0)*gconst79*new_r11))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x250=IKsin(j4);
IkReal x251=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
IkReal x252=IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))));
IkReal x253=((1.0)*x252);
evalcond[0]=x250;
evalcond[1]=((-1.0)*x251);
evalcond[2]=(((gconst79*x250))+new_r10);
evalcond[3]=(((gconst79*x251))+new_r11);
evalcond[4]=((((-1.0)*x250*x253))+new_r00);
evalcond[5]=((((-1.0)*x251*x253))+new_r01);
evalcond[6]=(x250+((gconst79*new_r10))+(((-1.0)*new_r00*x253)));
evalcond[7]=((((-1.0)*new_r01*x253))+x251+((gconst79*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x254 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x254.valid){
continue;
}
CheckValue<IkReal> x255=IKPowWithIntegerCheck(IKsign(gconst79),-1);
if(!x255.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x254.value)+(((1.5707963267949)*(x255.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x256=IKsin(j4);
IkReal x257=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
IkReal x258=IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))));
IkReal x259=((1.0)*x258);
evalcond[0]=x256;
evalcond[1]=((-1.0)*x257);
evalcond[2]=(((gconst79*x256))+new_r10);
evalcond[3]=(((gconst79*x257))+new_r11);
evalcond[4]=((((-1.0)*x256*x259))+new_r00);
evalcond[5]=((((-1.0)*x257*x259))+new_r01);
evalcond[6]=(x256+((gconst79*new_r10))+(((-1.0)*new_r00*x259)));
evalcond[7]=((((-1.0)*new_r01*x259))+x257+((gconst79*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x260=new_r22*new_r22;
CheckValue<IkReal> x261=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x260))),-1);
if(!x261.valid){
continue;
}
if((((-1.0)*x260*(x261.value))) < -0.00001)
continue;
IkReal gconst79=((-1.0)*(IKsqrt(((-1.0)*x260*(x261.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst79)))))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x262=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
sj2=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))))));
cj2=gconst79;
if( (gconst79) < -1-IKFAST_SINCOS_THRESH || (gconst79) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=((-1.0)*(IKacos(gconst79)));
CheckValue<IkReal> x263=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x262))),-1);
if(!x263.valid){
continue;
}
if((((-1.0)*x262*(x263.value))) < -0.00001)
continue;
IkReal gconst79=((-1.0)*(IKsqrt(((-1.0)*x262*(x263.value)))));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x264=IKPowWithIntegerCheck(gconst79,-1);
if(!x264.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x264.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79))))))))+(((-1.0)*gconst79*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x264.value)))+IKsqr(((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79))))))))+(((-1.0)*gconst79*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10*(x264.value)), ((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79))))))))+(((-1.0)*gconst79*new_r11))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x265=IKsin(j4);
IkReal x266=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
IkReal x267=IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))));
evalcond[0]=x265;
evalcond[1]=((-1.0)*x266);
evalcond[2]=(((gconst79*x265))+new_r10);
evalcond[3]=(((gconst79*x266))+new_r11);
evalcond[4]=(new_r00+((x265*x267)));
evalcond[5]=(((x266*x267))+new_r01);
evalcond[6]=(x265+((gconst79*new_r10))+((new_r00*x267)));
evalcond[7]=(x266+((gconst79*new_r11))+((new_r01*x267)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x268 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x268.valid){
continue;
}
CheckValue<IkReal> x269=IKPowWithIntegerCheck(IKsign(gconst79),-1);
if(!x269.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x268.value)+(((1.5707963267949)*(x269.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x270=IKsin(j4);
IkReal x271=IKcos(j4);
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
IkReal x272=IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))));
evalcond[0]=x270;
evalcond[1]=((-1.0)*x271);
evalcond[2]=(((gconst79*x270))+new_r10);
evalcond[3]=(((gconst79*x271))+new_r11);
evalcond[4]=(((x270*x272))+new_r00);
evalcond[5]=(((x271*x272))+new_r01);
evalcond[6]=(x270+((new_r00*x272))+((gconst79*new_r10)));
evalcond[7]=(x271+((gconst79*new_r11))+((new_r01*x272)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x273=(new_r01*new_r22);
IkReal x274=(cj2*new_r11);
CheckValue<IkReal> x275=IKPowWithIntegerCheck(cj2,-1);
if(!x275.valid){
continue;
}
if( IKabs(((x275.value)*(((((-1.0)*x273))+((new_r22*sj2*x274))+((x273*(cj2*cj2)))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x274))+((new_r01*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x275.value)*(((((-1.0)*x273))+((new_r22*sj2*x274))+((x273*(cj2*cj2)))+(((-1.0)*new_r10))))))+IKsqr(((((-1.0)*x274))+((new_r01*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x275.value)*(((((-1.0)*x273))+((new_r22*sj2*x274))+((x273*(cj2*cj2)))+(((-1.0)*new_r10))))), ((((-1.0)*x274))+((new_r01*sj2))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x276=IKcos(j4);
IkReal x277=IKsin(j4);
IkReal x278=(cj2*new_r01);
IkReal x279=(new_r10*sj2);
IkReal x280=((1.0)*new_r22);
IkReal x281=((1.0)*sj2);
IkReal x282=(new_r11*sj2);
IkReal x283=(cj2*new_r00);
IkReal x284=(cj2*x277);
IkReal x285=(new_r22*x276);
evalcond[0]=((((-1.0)*new_r00*x281))+x277+((cj2*new_r10)));
evalcond[1]=(x276+(((-1.0)*new_r01*x281))+((cj2*new_r11)));
evalcond[2]=(x279+x285+x283);
evalcond[3]=(((sj2*x285))+x284+new_r10);
evalcond[4]=((((-1.0)*x277*x280))+x278+x282);
evalcond[5]=((((-1.0)*x277*x281))+((cj2*x285))+new_r00);
evalcond[6]=((((-1.0)*sj2*x277*x280))+new_r11+((cj2*x276)));
evalcond[7]=((((-1.0)*x280*x282))+x277+(((-1.0)*x278*x280)));
evalcond[8]=((((-1.0)*x276*x281))+(((-1.0)*x280*x284))+new_r01);
evalcond[9]=((((-1.0)*x276))+(((-1.0)*x280*x283))+(((-1.0)*x279*x280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x286=((1.0)*cj2);
CheckValue<IkReal> x287=IKPowWithIntegerCheck(new_r22,-1);
if(!x287.valid){
continue;
}
if( IKabs((((new_r00*sj2))+(((-1.0)*new_r10*x286)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x287.value)*(((((-1.0)*new_r00*x286))+(((-1.0)*new_r10*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj2))+(((-1.0)*new_r10*x286))))+IKsqr(((x287.value)*(((((-1.0)*new_r00*x286))+(((-1.0)*new_r10*sj2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*sj2))+(((-1.0)*new_r10*x286))), ((x287.value)*(((((-1.0)*new_r00*x286))+(((-1.0)*new_r10*sj2))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x288=IKcos(j4);
IkReal x289=IKsin(j4);
IkReal x290=(cj2*new_r01);
IkReal x291=(new_r10*sj2);
IkReal x292=((1.0)*new_r22);
IkReal x293=((1.0)*sj2);
IkReal x294=(new_r11*sj2);
IkReal x295=(cj2*new_r00);
IkReal x296=(cj2*x289);
IkReal x297=(new_r22*x288);
evalcond[0]=(x289+((cj2*new_r10))+(((-1.0)*new_r00*x293)));
evalcond[1]=((((-1.0)*new_r01*x293))+x288+((cj2*new_r11)));
evalcond[2]=(x291+x295+x297);
evalcond[3]=(x296+new_r10+((sj2*x297)));
evalcond[4]=((((-1.0)*x289*x292))+x290+x294);
evalcond[5]=(((cj2*x297))+(((-1.0)*x289*x293))+new_r00);
evalcond[6]=((((-1.0)*sj2*x289*x292))+((cj2*x288))+new_r11);
evalcond[7]=((((-1.0)*x290*x292))+x289+(((-1.0)*x292*x294)));
evalcond[8]=((((-1.0)*x288*x293))+new_r01+(((-1.0)*x292*x296)));
evalcond[9]=((((-1.0)*x291*x292))+(((-1.0)*x288))+(((-1.0)*x292*x295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x298=cj2*cj2;
IkReal x299=new_r22*new_r22;
IkReal x300=(new_r22*sj2);
IkReal x301=((1.0)*cj2);
CheckValue<IkReal> x302=IKPowWithIntegerCheck(IKsign((x298+x299+(((-1.0)*x298*x299)))),-1);
if(!x302.valid){
continue;
}
CheckValue<IkReal> x303 = IKatan2WithCheck(IkReal((((new_r11*x300))+(((-1.0)*new_r10*x301)))),IkReal(((((-1.0)*new_r11*x301))+(((-1.0)*new_r10*x300)))),IKFAST_ATAN2_MAGTHRESH);
if(!x303.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x302.value)))+(x303.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x304=IKcos(j4);
IkReal x305=IKsin(j4);
IkReal x306=(cj2*new_r01);
IkReal x307=(new_r10*sj2);
IkReal x308=((1.0)*new_r22);
IkReal x309=((1.0)*sj2);
IkReal x310=(new_r11*sj2);
IkReal x311=(cj2*new_r00);
IkReal x312=(cj2*x305);
IkReal x313=(new_r22*x304);
evalcond[0]=(x305+((cj2*new_r10))+(((-1.0)*new_r00*x309)));
evalcond[1]=(x304+(((-1.0)*new_r01*x309))+((cj2*new_r11)));
evalcond[2]=(x307+x311+x313);
evalcond[3]=(x312+((sj2*x313))+new_r10);
evalcond[4]=(x306+x310+(((-1.0)*x305*x308)));
evalcond[5]=(((cj2*x313))+(((-1.0)*x305*x309))+new_r00);
evalcond[6]=(((cj2*x304))+new_r11+(((-1.0)*sj2*x305*x308)));
evalcond[7]=((((-1.0)*x308*x310))+x305+(((-1.0)*x306*x308)));
evalcond[8]=((((-1.0)*x308*x312))+(((-1.0)*x304*x309))+new_r01);
evalcond[9]=((((-1.0)*x304))+(((-1.0)*x308*x311))+(((-1.0)*x307*x308)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x315=IKPowWithIntegerCheck(sj3,-1);
if(!x315.valid){
continue;
}
IkReal x314=x315.value;
CheckValue<IkReal> x316=IKPowWithIntegerCheck(new_r12,-1);
if(!x316.valid){
continue;
}
if( IKabs((x314*(x316.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x314)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x314*(x316.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))))+IKsqr((new_r02*x314))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x314*(x316.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))), (new_r02*x314));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x317=IKcos(j2);
IkReal x318=IKsin(j2);
IkReal x319=((1.0)*new_r02);
IkReal x320=(sj3*x318);
IkReal x321=(sj3*x317);
IkReal x322=(new_r12*x318);
evalcond[0]=((((-1.0)*x321))+new_r02);
evalcond[1]=((((-1.0)*x320))+new_r12);
evalcond[2]=((((-1.0)*x318*x319))+((new_r12*x317)));
evalcond[3]=((((-1.0)*sj3))+x322+((new_r02*x317)));
evalcond[4]=(((new_r00*x321))+((new_r10*x320))+((cj3*new_r20)));
evalcond[5]=(((new_r01*x321))+((new_r11*x320))+((cj3*new_r21)));
evalcond[6]=((-1.0)+((new_r12*x320))+((cj3*new_r22))+((new_r02*x321)));
evalcond[7]=((((-1.0)*cj3*x322))+((new_r22*sj3))+(((-1.0)*cj3*x317*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=IKsign(sj3);
j4eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=cj3;
j4eval[2]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x323=((1.0)*cj2);
if( IKabs((((new_r00*sj2))+(((-1.0)*new_r10*x323)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*x323))+(((-1.0)*new_r10*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj2))+(((-1.0)*new_r10*x323))))+IKsqr(((((-1.0)*new_r00*x323))+(((-1.0)*new_r10*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*sj2))+(((-1.0)*new_r10*x323))), ((((-1.0)*new_r00*x323))+(((-1.0)*new_r10*sj2))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x324=IKcos(j4);
IkReal x325=IKsin(j4);
IkReal x326=((1.0)*sj2);
IkReal x327=(cj2*x324);
IkReal x328=((1.0)*x325);
IkReal x329=(x325*x326);
evalcond[0]=(((new_r10*sj2))+x324+((cj2*new_r00)));
evalcond[1]=(x325+(((-1.0)*new_r00*x326))+((cj2*new_r10)));
evalcond[2]=(x324+(((-1.0)*new_r01*x326))+((cj2*new_r11)));
evalcond[3]=(((cj2*x325))+((sj2*x324))+new_r10);
evalcond[4]=(((new_r11*sj2))+(((-1.0)*x328))+((cj2*new_r01)));
evalcond[5]=((((-1.0)*x329))+x327+new_r00);
evalcond[6]=((((-1.0)*x329))+x327+new_r11);
evalcond[7]=((((-1.0)*cj2*x328))+new_r01+(((-1.0)*x324*x326)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x330=((1.0)*cj2);
if( IKabs(((((-1.0)*new_r10*x330))+(((-1.0)*new_r11*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x330))+((new_r10*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r10*x330))+(((-1.0)*new_r11*sj2))))+IKsqr(((((-1.0)*new_r11*x330))+((new_r10*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r10*x330))+(((-1.0)*new_r11*sj2))), ((((-1.0)*new_r11*x330))+((new_r10*sj2))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x331=IKsin(j4);
IkReal x332=IKcos(j4);
IkReal x333=((1.0)*sj2);
IkReal x334=(cj2*x331);
IkReal x335=(cj2*x332);
IkReal x336=(x332*x333);
evalcond[0]=(((new_r11*sj2))+x331+((cj2*new_r01)));
evalcond[1]=(x331+(((-1.0)*new_r00*x333))+((cj2*new_r10)));
evalcond[2]=(x332+((cj2*new_r11))+(((-1.0)*new_r01*x333)));
evalcond[3]=(((new_r10*sj2))+(((-1.0)*x332))+((cj2*new_r00)));
evalcond[4]=(((sj2*x331))+x335+new_r11);
evalcond[5]=(x334+(((-1.0)*x336))+new_r10);
evalcond[6]=(x334+(((-1.0)*x336))+new_r01);
evalcond[7]=((((-1.0)*x335))+(((-1.0)*x331*x333))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x337=IKsin(j4);
IkReal x338=IKcos(j4);
IkReal x339=((1.0)*sj2);
evalcond[0]=(x337+new_r21);
evalcond[1]=((((-1.0)*x338))+new_r20);
evalcond[2]=(((cj2*x337))+new_r10);
evalcond[3]=(((cj2*x338))+new_r11);
evalcond[4]=((((-1.0)*x337*x339))+new_r00);
evalcond[5]=((((-1.0)*x338*x339))+new_r01);
evalcond[6]=(x337+(((-1.0)*new_r00*x339))+((cj2*new_r10)));
evalcond[7]=(x338+((cj2*new_r11))+(((-1.0)*new_r01*x339)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x340=IKsin(j4);
IkReal x341=IKcos(j4);
IkReal x342=((1.0)*sj2);
evalcond[0]=(x341+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x340)));
evalcond[2]=(new_r10+((cj2*x340)));
evalcond[3]=(new_r11+((cj2*x341)));
evalcond[4]=((((-1.0)*x340*x342))+new_r00);
evalcond[5]=((((-1.0)*x341*x342))+new_r01);
evalcond[6]=(x340+(((-1.0)*new_r00*x342))+((cj2*new_r10)));
evalcond[7]=(x341+((cj2*new_r11))+(((-1.0)*new_r01*x342)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x343=IKsin(j4);
IkReal x344=IKcos(j4);
IkReal x345=((1.0)*cj3);
IkReal x346=((1.0)*x344);
evalcond[0]=(x343+new_r10);
evalcond[1]=(x344+new_r11);
evalcond[2]=(((sj3*x343))+new_r21);
evalcond[3]=(new_r00+((cj3*x344)));
evalcond[4]=(new_r20+(((-1.0)*sj3*x346)));
evalcond[5]=((((-1.0)*x343*x345))+new_r01);
evalcond[6]=(x343+(((-1.0)*new_r01*x345))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*new_r00*x345))+(((-1.0)*x346)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x347=IKsin(j4);
IkReal x348=IKcos(j4);
IkReal x349=((1.0)*x348);
evalcond[0]=(((sj3*x347))+new_r21);
evalcond[1]=(x347+(((-1.0)*new_r10)));
evalcond[2]=(x348+(((-1.0)*new_r11)));
evalcond[3]=(new_r20+(((-1.0)*sj3*x349)));
evalcond[4]=((((-1.0)*new_r00))+((cj3*x348)));
evalcond[5]=((((-1.0)*cj3*x347))+(((-1.0)*new_r01)));
evalcond[6]=(x347+((cj3*new_r01))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+((cj3*new_r00))+(((-1.0)*x349)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x350=IKsin(j4);
IkReal x351=IKcos(j4);
IkReal x352=((1.0)*cj3);
IkReal x353=((1.0)*x351);
evalcond[0]=(((sj3*x350))+new_r21);
evalcond[1]=(x350+(((-1.0)*new_r00)));
evalcond[2]=(x351+(((-1.0)*new_r01)));
evalcond[3]=(((cj3*x351))+new_r10);
evalcond[4]=(new_r20+(((-1.0)*sj3*x353)));
evalcond[5]=(new_r11+(((-1.0)*x350*x352)));
evalcond[6]=(x350+(((-1.0)*new_r11*x352))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x353))+(((-1.0)*new_r10*x352)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x354=IKsin(j4);
IkReal x355=IKcos(j4);
IkReal x356=((1.0)*x355);
evalcond[0]=(x354+new_r00);
evalcond[1]=(x355+new_r01);
evalcond[2]=(((sj3*x354))+new_r21);
evalcond[3]=(new_r20+(((-1.0)*sj3*x356)));
evalcond[4]=(((cj3*x355))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*cj3*x354))+(((-1.0)*new_r11)));
evalcond[6]=(x354+((cj3*new_r11))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x356))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=((-1.0)*new_r22);
op[1]=0;
op[2]=new_r22;
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x358=IKPowWithIntegerCheck(sj3,-1);
if(!x358.valid){
continue;
}
IkReal x357=x358.value;
CheckValue<IkReal> x359=IKPowWithIntegerCheck(cj3,-1);
if(!x359.valid){
continue;
}
CheckValue<IkReal> x360=IKPowWithIntegerCheck(sj2,-1);
if(!x360.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x357)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x357*(x359.value)*(x360.value)*(((((-1.0)*new_r10*sj3))+((cj2*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x357))+IKsqr((x357*(x359.value)*(x360.value)*(((((-1.0)*new_r10*sj3))+((cj2*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x357), (x357*(x359.value)*(x360.value)*(((((-1.0)*new_r10*sj3))+((cj2*new_r21))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x361=IKsin(j4);
IkReal x362=IKcos(j4);
IkReal x363=(cj2*new_r01);
IkReal x364=((1.0)*cj3);
IkReal x365=(new_r10*sj2);
IkReal x366=(new_r11*sj2);
IkReal x367=(cj2*new_r00);
IkReal x368=((1.0)*sj2);
IkReal x369=(cj2*x361);
IkReal x370=(cj2*x362);
IkReal x371=((1.0)*x362);
IkReal x372=(cj3*x362);
evalcond[0]=(((sj3*x361))+new_r21);
evalcond[1]=((((-1.0)*sj3*x371))+new_r20);
evalcond[2]=((((-1.0)*new_r00*x368))+x361+((cj2*new_r10)));
evalcond[3]=(x362+((cj2*new_r11))+(((-1.0)*new_r01*x368)));
evalcond[4]=(x372+x365+x367);
evalcond[5]=(x369+((sj2*x372))+new_r10);
evalcond[6]=((((-1.0)*x361*x364))+x363+x366);
evalcond[7]=((((-1.0)*x361*x368))+new_r00+((cj3*x370)));
evalcond[8]=((((-1.0)*sj2*x361*x364))+x370+new_r11);
evalcond[9]=((((-1.0)*x362*x368))+(((-1.0)*x364*x369))+new_r01);
evalcond[10]=((((-1.0)*x363*x364))+x361+(((-1.0)*x364*x366))+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+(((-1.0)*x371))+(((-1.0)*x364*x367))+(((-1.0)*x364*x365)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x374=IKPowWithIntegerCheck(sj3,-1);
if(!x374.valid){
continue;
}
IkReal x373=x374.value;
CheckValue<IkReal> x375=IKPowWithIntegerCheck(cj2,-1);
if(!x375.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x373)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x373*(x375.value)*(((((-1.0)*cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x373))+IKsqr((x373*(x375.value)*(((((-1.0)*cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x373), (x373*(x375.value)*(((((-1.0)*cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x376=IKsin(j4);
IkReal x377=IKcos(j4);
IkReal x378=(cj2*new_r01);
IkReal x379=((1.0)*cj3);
IkReal x380=(new_r10*sj2);
IkReal x381=(new_r11*sj2);
IkReal x382=(cj2*new_r00);
IkReal x383=((1.0)*sj2);
IkReal x384=(cj2*x376);
IkReal x385=(cj2*x377);
IkReal x386=((1.0)*x377);
IkReal x387=(cj3*x377);
evalcond[0]=(((sj3*x376))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj3*x386)));
evalcond[2]=((((-1.0)*new_r00*x383))+x376+((cj2*new_r10)));
evalcond[3]=((((-1.0)*new_r01*x383))+x377+((cj2*new_r11)));
evalcond[4]=(x387+x382+x380);
evalcond[5]=(x384+new_r10+((sj2*x387)));
evalcond[6]=(x381+x378+(((-1.0)*x376*x379)));
evalcond[7]=(((cj3*x385))+(((-1.0)*x376*x383))+new_r00);
evalcond[8]=(x385+new_r11+(((-1.0)*sj2*x376*x379)));
evalcond[9]=((((-1.0)*x379*x384))+new_r01+(((-1.0)*x377*x383)));
evalcond[10]=((((-1.0)*x378*x379))+(((-1.0)*x379*x381))+x376+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+(((-1.0)*x379*x380))+(((-1.0)*x379*x382))+(((-1.0)*x386)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x388=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x388.valid){
continue;
}
CheckValue<IkReal> x389 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x389.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x388.value)))+(x389.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x390=IKsin(j4);
IkReal x391=IKcos(j4);
IkReal x392=(cj2*new_r01);
IkReal x393=((1.0)*cj3);
IkReal x394=(new_r10*sj2);
IkReal x395=(new_r11*sj2);
IkReal x396=(cj2*new_r00);
IkReal x397=((1.0)*sj2);
IkReal x398=(cj2*x390);
IkReal x399=(cj2*x391);
IkReal x400=((1.0)*x391);
IkReal x401=(cj3*x391);
evalcond[0]=(((sj3*x390))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj3*x400)));
evalcond[2]=(x390+((cj2*new_r10))+(((-1.0)*new_r00*x397)));
evalcond[3]=((((-1.0)*new_r01*x397))+x391+((cj2*new_r11)));
evalcond[4]=(x394+x396+x401);
evalcond[5]=(((sj2*x401))+x398+new_r10);
evalcond[6]=(x395+x392+(((-1.0)*x390*x393)));
evalcond[7]=(((cj3*x399))+(((-1.0)*x390*x397))+new_r00);
evalcond[8]=(x399+(((-1.0)*sj2*x390*x393))+new_r11);
evalcond[9]=((((-1.0)*x391*x397))+new_r01+(((-1.0)*x393*x398)));
evalcond[10]=(x390+((new_r21*sj3))+(((-1.0)*x393*x395))+(((-1.0)*x392*x393)));
evalcond[11]=(((new_r20*sj3))+(((-1.0)*x393*x394))+(((-1.0)*x393*x396))+(((-1.0)*x400)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x402=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x402.valid){
continue;
}
CheckValue<IkReal> x403 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x403.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x402.value)))+(x403.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(new_r21+((sj3*(IKsin(j4)))));
evalcond[1]=((((-1.0)*sj3*(IKcos(j4))))+new_r20);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=new_r00;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x404=((1.0)*new_r10);
IkReal x405=((new_r10*new_r10)+(new_r00*new_r00));
j2eval[0]=x405;
j2eval[1]=IKsign(x405);
j2eval[2]=((IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x404)))))+(IKabs((((new_r00*sj4))+(((-1.0)*cj4*x404))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x406=((1.0)*cj4);
IkReal x407=(((new_r10*new_r11))+((new_r00*new_r01)));
j2eval[0]=x407;
j2eval[1]=((IKabs((((cj4*new_r00))+(((-1.0)*new_r11*x406)))))+(IKabs(((((-1.0)*new_r10*x406))+(((-1.0)*new_r01*x406))))));
j2eval[2]=IKsign(x407);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x408=((1.0)*new_r10);
IkReal x409=(((cj4*new_r00))+(((-1.0)*sj4*x408)));
j2eval[0]=x409;
j2eval[1]=IKsign(x409);
j2eval[2]=((IKabs(((((-1.0)*(cj4*cj4)))+(new_r10*new_r10))))+(IKabs((((cj4*sj4))+(((-1.0)*new_r00*x408))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x412 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x412)==0){
continue;
}
IkReal x410=pow(x412,-0.5);
IkReal x411=((-1.0)*x410);
CheckValue<IkReal> x413 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x413.valid){
continue;
}
IkReal gconst66=((-1.0)*(x413.value));
IkReal gconst67=(new_r00*x411);
IkReal gconst68=(new_r10*x411);
CheckValue<IkReal> x414 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x414.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x414.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
CheckValue<IkReal> x418 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x418.valid){
continue;
}
IkReal x415=((-1.0)*(x418.value));
IkReal x416=x410;
IkReal x417=((-1.0)*x416);
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x415;
IkReal gconst66=x415;
IkReal gconst67=(new_r00*x417);
IkReal gconst68=(new_r10*x417);
IkReal x419=((new_r10*new_r10)+(new_r00*new_r00));
j2eval[0]=x419;
j2eval[1]=IKsign(x419);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x423 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x423.valid){
continue;
}
IkReal x420=((-1.0)*(x423.value));
IkReal x421=x410;
IkReal x422=((-1.0)*x421);
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x420;
IkReal gconst66=x420;
IkReal gconst67=(new_r00*x422);
IkReal gconst68=(new_r10*x422);
IkReal x424=new_r10*new_r10;
IkReal x425=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x426=x410;
IkReal x427=(new_r10*x426);
j2eval[0]=x425;
j2eval[1]=((IKabs((((x424*x426))+((new_r01*x427)))))+(IKabs(((((-1.0)*new_r00*x427))+((new_r11*x427))))));
j2eval[2]=IKsign(x425);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x431 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x431.valid){
continue;
}
IkReal x428=((-1.0)*(x431.value));
IkReal x429=x410;
IkReal x430=((-1.0)*x429);
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x428;
IkReal gconst66=x428;
IkReal gconst67=(new_r00*x430);
IkReal gconst68=(new_r10*x430);
IkReal x432=new_r10*new_r10;
IkReal x433=new_r00*new_r00;
CheckValue<IkReal> x440=IKPowWithIntegerCheck((x432+x433),-1);
if(!x440.valid){
continue;
}
IkReal x434=x440.value;
IkReal x435=(x432*x434);
CheckValue<IkReal> x441=IKPowWithIntegerCheck(((((-1.0)*x432))+(((-1.0)*x433))),-1);
if(!x441.valid){
continue;
}
IkReal x436=x441.value;
IkReal x437=((1.0)*x436);
IkReal x438=(new_r00*x437);
IkReal x439=(new_r10*x437);
j2eval[0]=((IKabs(((((-1.0)*x435))+((x434*(x433*x433)))+((x433*x435)))))+(IKabs(((((-1.0)*x438*(new_r10*new_r10*new_r10)))+(((-1.0)*new_r10*x438))+(((-1.0)*new_r10*x438*(new_r00*new_r00)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x442=IKPowWithIntegerCheck(IKsign((((gconst68*new_r10))+((gconst67*new_r00)))),-1);
if(!x442.valid){
continue;
}
CheckValue<IkReal> x443 = IKatan2WithCheck(IkReal(((((-1.0)*(gconst68*gconst68)))+(new_r00*new_r00))),IkReal(((((-1.0)*new_r00*new_r10))+(((-1.0)*gconst67*gconst68)))),IKFAST_ATAN2_MAGTHRESH);
if(!x443.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x442.value)))+(x443.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x444=IKcos(j2);
IkReal x445=IKsin(j2);
IkReal x446=(gconst68*x444);
IkReal x447=((1.0)*x445);
IkReal x448=(gconst67*x444);
IkReal x449=(gconst67*x447);
evalcond[0]=(((new_r00*x444))+gconst68+((new_r10*x445)));
evalcond[1]=(x448+((gconst68*x445))+new_r10);
evalcond[2]=((((-1.0)*new_r00*x447))+gconst67+((new_r10*x444)));
evalcond[3]=((((-1.0)*new_r01*x447))+gconst68+((new_r11*x444)));
evalcond[4]=((((-1.0)*x449))+x446+new_r00);
evalcond[5]=((((-1.0)*x449))+x446+new_r11);
evalcond[6]=(((new_r01*x444))+(((-1.0)*gconst67))+((new_r11*x445)));
evalcond[7]=((((-1.0)*x448))+(((-1.0)*gconst68*x447))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x450=((1.0)*gconst68);
CheckValue<IkReal> x451 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x450))+((gconst68*new_r00)))),IkReal(((((-1.0)*new_r10*x450))+(((-1.0)*new_r01*x450)))),IKFAST_ATAN2_MAGTHRESH);
if(!x451.valid){
continue;
}
CheckValue<IkReal> x452=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x452.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x451.value)+(((1.5707963267949)*(x452.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x453=IKcos(j2);
IkReal x454=IKsin(j2);
IkReal x455=(gconst68*x453);
IkReal x456=((1.0)*x454);
IkReal x457=(gconst67*x453);
IkReal x458=(gconst67*x456);
evalcond[0]=(((new_r10*x454))+((new_r00*x453))+gconst68);
evalcond[1]=(((gconst68*x454))+x457+new_r10);
evalcond[2]=(((new_r10*x453))+gconst67+(((-1.0)*new_r00*x456)));
evalcond[3]=(((new_r11*x453))+(((-1.0)*new_r01*x456))+gconst68);
evalcond[4]=((((-1.0)*x458))+x455+new_r00);
evalcond[5]=((((-1.0)*x458))+x455+new_r11);
evalcond[6]=(((new_r11*x454))+(((-1.0)*gconst67))+((new_r01*x453)));
evalcond[7]=((((-1.0)*gconst68*x456))+(((-1.0)*x457))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x459=((1.0)*new_r10);
CheckValue<IkReal> x460 = IKatan2WithCheck(IkReal(((((-1.0)*gconst68*x459))+((gconst67*new_r00)))),IkReal(((((-1.0)*gconst68*new_r00))+(((-1.0)*gconst67*x459)))),IKFAST_ATAN2_MAGTHRESH);
if(!x460.valid){
continue;
}
CheckValue<IkReal> x461=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x461.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x460.value)+(((1.5707963267949)*(x461.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x462=IKcos(j2);
IkReal x463=IKsin(j2);
IkReal x464=(gconst68*x462);
IkReal x465=((1.0)*x463);
IkReal x466=(gconst67*x462);
IkReal x467=(gconst67*x465);
evalcond[0]=(((new_r10*x463))+((new_r00*x462))+gconst68);
evalcond[1]=(((gconst68*x463))+x466+new_r10);
evalcond[2]=(((new_r10*x462))+gconst67+(((-1.0)*new_r00*x465)));
evalcond[3]=(((new_r11*x462))+gconst68+(((-1.0)*new_r01*x465)));
evalcond[4]=((((-1.0)*x467))+x464+new_r00);
evalcond[5]=((((-1.0)*x467))+x464+new_r11);
evalcond[6]=(((new_r11*x463))+(((-1.0)*gconst67))+((new_r01*x462)));
evalcond[7]=((((-1.0)*gconst68*x465))+(((-1.0)*x466))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x470 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x470)==0){
continue;
}
IkReal x468=pow(x470,-0.5);
IkReal x469=((1.0)*x468);
CheckValue<IkReal> x471 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x471.valid){
continue;
}
IkReal gconst69=((3.14159265358979)+(((-1.0)*(x471.value))));
IkReal gconst70=(new_r00*x469);
IkReal gconst71=(new_r10*x469);
CheckValue<IkReal> x472 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x472.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x472.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
CheckValue<IkReal> x476 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x476.valid){
continue;
}
IkReal x473=((1.0)*(x476.value));
IkReal x474=x468;
IkReal x475=((1.0)*x474);
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x473)));
IkReal gconst69=((3.14159265358979)+(((-1.0)*x473)));
IkReal gconst70=(new_r00*x475);
IkReal gconst71=(new_r10*x475);
IkReal x477=((new_r10*new_r10)+(new_r00*new_r00));
j2eval[0]=x477;
j2eval[1]=IKsign(x477);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x481 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x481.valid){
continue;
}
IkReal x478=((1.0)*(x481.value));
IkReal x479=x468;
IkReal x480=((1.0)*x479);
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x478)));
IkReal gconst69=((3.14159265358979)+(((-1.0)*x478)));
IkReal gconst70=(new_r00*x480);
IkReal gconst71=(new_r10*x480);
IkReal x482=new_r10*new_r10;
IkReal x483=(new_r10*new_r11);
IkReal x484=(((new_r00*new_r01))+x483);
IkReal x485=x468;
IkReal x486=((1.0)*x485);
j2eval[0]=x484;
j2eval[1]=((IKabs(((((-1.0)*new_r01*new_r10*x486))+(((-1.0)*x482*x486)))))+(IKabs((((new_r00*new_r10*x485))+(((-1.0)*x483*x486))))));
j2eval[2]=IKsign(x484);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x490 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x490.valid){
continue;
}
IkReal x487=((1.0)*(x490.value));
IkReal x488=x468;
IkReal x489=((1.0)*x488);
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x487)));
IkReal gconst69=((3.14159265358979)+(((-1.0)*x487)));
IkReal gconst70=(new_r00*x489);
IkReal gconst71=(new_r10*x489);
IkReal x491=new_r10*new_r10;
IkReal x492=new_r00*new_r00;
CheckValue<IkReal> x499=IKPowWithIntegerCheck((x492+x491),-1);
if(!x499.valid){
continue;
}
IkReal x493=x499.value;
IkReal x494=(x491*x493);
CheckValue<IkReal> x500=IKPowWithIntegerCheck(((((-1.0)*x491))+(((-1.0)*x492))),-1);
if(!x500.valid){
continue;
}
IkReal x495=x500.value;
IkReal x496=((1.0)*x495);
IkReal x497=(new_r00*x496);
IkReal x498=(new_r10*x496);
j2eval[0]=((IKabs(((((-1.0)*new_r10*x497))+(((-1.0)*x497*(new_r10*new_r10*new_r10)))+(((-1.0)*new_r10*x497*(new_r00*new_r00))))))+(IKabs(((((-1.0)*x494))+((x493*(x492*x492)))+((x492*x494))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x501 = IKatan2WithCheck(IkReal(((((-1.0)*(gconst71*gconst71)))+(new_r00*new_r00))),IkReal(((((-1.0)*gconst70*gconst71))+(((-1.0)*new_r00*new_r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x501.valid){
continue;
}
CheckValue<IkReal> x502=IKPowWithIntegerCheck(IKsign((((gconst70*new_r00))+((gconst71*new_r10)))),-1);
if(!x502.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x501.value)+(((1.5707963267949)*(x502.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x503=IKcos(j2);
IkReal x504=IKsin(j2);
IkReal x505=((1.0)*gconst70);
IkReal x506=(gconst71*x503);
IkReal x507=(gconst71*x504);
IkReal x508=((1.0)*x504);
IkReal x509=(x504*x505);
evalcond[0]=(gconst71+((new_r10*x504))+((new_r00*x503)));
evalcond[1]=(x507+new_r10+((gconst70*x503)));
evalcond[2]=((((-1.0)*new_r00*x508))+gconst70+((new_r10*x503)));
evalcond[3]=((((-1.0)*new_r01*x508))+gconst71+((new_r11*x503)));
evalcond[4]=((((-1.0)*x509))+x506+new_r00);
evalcond[5]=((((-1.0)*x509))+x506+new_r11);
evalcond[6]=((((-1.0)*x505))+((new_r11*x504))+((new_r01*x503)));
evalcond[7]=((((-1.0)*x503*x505))+new_r01+(((-1.0)*x507)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x510=((1.0)*gconst71);
CheckValue<IkReal> x511=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x511.valid){
continue;
}
CheckValue<IkReal> x512 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x510))+((gconst71*new_r00)))),IkReal(((((-1.0)*new_r10*x510))+(((-1.0)*new_r01*x510)))),IKFAST_ATAN2_MAGTHRESH);
if(!x512.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x511.value)))+(x512.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x513=IKcos(j2);
IkReal x514=IKsin(j2);
IkReal x515=((1.0)*gconst70);
IkReal x516=(gconst71*x513);
IkReal x517=(gconst71*x514);
IkReal x518=((1.0)*x514);
IkReal x519=(x514*x515);
evalcond[0]=(((new_r00*x513))+((new_r10*x514))+gconst71);
evalcond[1]=(((gconst70*x513))+x517+new_r10);
evalcond[2]=(((new_r10*x513))+gconst70+(((-1.0)*new_r00*x518)));
evalcond[3]=(((new_r11*x513))+gconst71+(((-1.0)*new_r01*x518)));
evalcond[4]=(x516+new_r00+(((-1.0)*x519)));
evalcond[5]=(x516+new_r11+(((-1.0)*x519)));
evalcond[6]=(((new_r01*x513))+((new_r11*x514))+(((-1.0)*x515)));
evalcond[7]=((((-1.0)*x517))+(((-1.0)*x513*x515))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x520=((1.0)*new_r10);
CheckValue<IkReal> x521=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x521.valid){
continue;
}
CheckValue<IkReal> x522 = IKatan2WithCheck(IkReal((((gconst70*new_r00))+(((-1.0)*gconst71*x520)))),IkReal(((((-1.0)*gconst71*new_r00))+(((-1.0)*gconst70*x520)))),IKFAST_ATAN2_MAGTHRESH);
if(!x522.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x521.value)))+(x522.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x523=IKcos(j2);
IkReal x524=IKsin(j2);
IkReal x525=((1.0)*gconst70);
IkReal x526=(gconst71*x523);
IkReal x527=(gconst71*x524);
IkReal x528=((1.0)*x524);
IkReal x529=(x524*x525);
evalcond[0]=(gconst71+((new_r10*x524))+((new_r00*x523)));
evalcond[1]=(((gconst70*x523))+x527+new_r10);
evalcond[2]=(gconst70+(((-1.0)*new_r00*x528))+((new_r10*x523)));
evalcond[3]=(gconst71+((new_r11*x523))+(((-1.0)*new_r01*x528)));
evalcond[4]=((((-1.0)*x529))+x526+new_r00);
evalcond[5]=((((-1.0)*x529))+x526+new_r11);
evalcond[6]=(((new_r01*x523))+((new_r11*x524))+(((-1.0)*x525)));
evalcond[7]=((((-1.0)*x523*x525))+(((-1.0)*x527))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x530=IKcos(j2);
IkReal x531=IKsin(j2);
IkReal x532=((1.0)*x531);
evalcond[0]=(x530+new_r10);
evalcond[1]=((((-1.0)*x532))+new_r00);
evalcond[2]=((((-1.0)*x532))+new_r11);
evalcond[3]=((((-1.0)*x530))+new_r01);
evalcond[4]=(((new_r10*x531))+((new_r00*x530)));
evalcond[5]=(((new_r11*x530))+(((-1.0)*new_r01*x532)));
evalcond[6]=((-1.0)+((new_r01*x530))+((new_r11*x531)));
evalcond[7]=((1.0)+(((-1.0)*new_r00*x532))+((new_r10*x530)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x533=IKsin(j2);
IkReal x534=IKcos(j2);
IkReal x535=((1.0)*x533);
evalcond[0]=(x533+new_r00);
evalcond[1]=(x533+new_r11);
evalcond[2]=(x534+new_r01);
evalcond[3]=((((-1.0)*x534))+new_r10);
evalcond[4]=(((new_r10*x533))+((new_r00*x534)));
evalcond[5]=(((new_r11*x534))+(((-1.0)*new_r01*x535)));
evalcond[6]=((1.0)+((new_r01*x534))+((new_r11*x533)));
evalcond[7]=((-1.0)+(((-1.0)*new_r00*x535))+((new_r10*x534)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r10*new_r10)+(new_r00*new_r00));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=1.0;
j3=0;
new_r10=0;
new_r00=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x537 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x537.valid){
continue;
}
IkReal x536=x537.value;
j2array[0]=((-1.0)*x536);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x536)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r01*(IKsin(j2))))+((new_r11*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=1.0;
j3=0;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x539 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x539.valid){
continue;
}
IkReal x538=x539.value;
j2array[0]=((-1.0)*x538);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x538)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r01*(IKsin(j2))))+((new_r11*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x540=((1.0)*new_r10);
CheckValue<IkReal> x541=IKPowWithIntegerCheck(IKsign((((cj4*new_r00))+(((-1.0)*sj4*x540)))),-1);
if(!x541.valid){
continue;
}
CheckValue<IkReal> x542 = IKatan2WithCheck(IkReal(((((-1.0)*new_r00*x540))+((cj4*sj4)))),IkReal(((((-1.0)*(cj4*cj4)))+(new_r10*new_r10))),IKFAST_ATAN2_MAGTHRESH);
if(!x542.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x541.value)))+(x542.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x543=IKsin(j2);
IkReal x544=IKcos(j2);
IkReal x545=((1.0)*sj4);
IkReal x546=(cj4*x544);
IkReal x547=((1.0)*x543);
IkReal x548=(x543*x545);
evalcond[0]=(((new_r00*x544))+cj4+((new_r10*x543)));
evalcond[1]=(((cj4*x543))+new_r10+((sj4*x544)));
evalcond[2]=(sj4+(((-1.0)*new_r00*x547))+((new_r10*x544)));
evalcond[3]=(cj4+((new_r11*x544))+(((-1.0)*new_r01*x547)));
evalcond[4]=((((-1.0)*x548))+x546+new_r00);
evalcond[5]=((((-1.0)*x548))+x546+new_r11);
evalcond[6]=(((new_r11*x543))+(((-1.0)*x545))+((new_r01*x544)));
evalcond[7]=((((-1.0)*x544*x545))+new_r01+(((-1.0)*cj4*x547)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x549=((1.0)*cj4);
CheckValue<IkReal> x550 = IKatan2WithCheck(IkReal((((cj4*new_r00))+(((-1.0)*new_r11*x549)))),IkReal(((((-1.0)*new_r10*x549))+(((-1.0)*new_r01*x549)))),IKFAST_ATAN2_MAGTHRESH);
if(!x550.valid){
continue;
}
CheckValue<IkReal> x551=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x551.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x550.value)+(((1.5707963267949)*(x551.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x552=IKsin(j2);
IkReal x553=IKcos(j2);
IkReal x554=((1.0)*sj4);
IkReal x555=(cj4*x553);
IkReal x556=((1.0)*x552);
IkReal x557=(x552*x554);
evalcond[0]=(cj4+((new_r10*x552))+((new_r00*x553)));
evalcond[1]=(((sj4*x553))+((cj4*x552))+new_r10);
evalcond[2]=(sj4+((new_r10*x553))+(((-1.0)*new_r00*x556)));
evalcond[3]=(cj4+((new_r11*x553))+(((-1.0)*new_r01*x556)));
evalcond[4]=((((-1.0)*x557))+x555+new_r00);
evalcond[5]=((((-1.0)*x557))+x555+new_r11);
evalcond[6]=(((new_r11*x552))+(((-1.0)*x554))+((new_r01*x553)));
evalcond[7]=((((-1.0)*x553*x554))+new_r01+(((-1.0)*cj4*x556)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x558=((1.0)*new_r10);
CheckValue<IkReal> x559=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x559.valid){
continue;
}
CheckValue<IkReal> x560 = IKatan2WithCheck(IkReal((((new_r00*sj4))+(((-1.0)*cj4*x558)))),IkReal(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x558)))),IKFAST_ATAN2_MAGTHRESH);
if(!x560.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x559.value)))+(x560.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x561=IKsin(j2);
IkReal x562=IKcos(j2);
IkReal x563=((1.0)*sj4);
IkReal x564=(cj4*x562);
IkReal x565=((1.0)*x561);
IkReal x566=(x561*x563);
evalcond[0]=(cj4+((new_r00*x562))+((new_r10*x561)));
evalcond[1]=(((sj4*x562))+new_r10+((cj4*x561)));
evalcond[2]=((((-1.0)*new_r00*x565))+sj4+((new_r10*x562)));
evalcond[3]=(cj4+((new_r11*x562))+(((-1.0)*new_r01*x565)));
evalcond[4]=(x564+new_r00+(((-1.0)*x566)));
evalcond[5]=(x564+new_r11+(((-1.0)*x566)));
evalcond[6]=(((new_r01*x562))+((new_r11*x561))+(((-1.0)*x563)));
evalcond[7]=((((-1.0)*cj4*x565))+(((-1.0)*x562*x563))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x567=((1.0)*sj4);
IkReal x568=(((new_r10*new_r11))+((new_r00*new_r01)));
j2eval[0]=x568;
j2eval[1]=((IKabs(((((-1.0)*new_r00*x567))+(((-1.0)*new_r11*x567)))))+(IKabs((((new_r01*sj4))+(((-1.0)*new_r10*x567))))));
j2eval[2]=IKsign(x568);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x569=((1.0)*new_r11);
IkReal x570=((new_r01*new_r01)+(new_r11*new_r11));
j2eval[0]=x570;
j2eval[1]=((IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x569)))))+(IKabs(((((-1.0)*sj4*x569))+((cj4*new_r01))))));
j2eval[2]=IKsign(x570);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x571=(((cj4*new_r01))+((new_r11*sj4)));
j2eval[0]=x571;
j2eval[1]=((IKabs(((-1.0)+((new_r01*new_r10))+(cj4*cj4))))+(IKabs(((((-1.0)*cj4*sj4))+(((-1.0)*new_r10*new_r11))))));
j2eval[2]=IKsign(x571);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x573 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x573)==0){
continue;
}
IkReal x572=pow(x573,-0.5);
CheckValue<IkReal> x574 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x574.valid){
continue;
}
IkReal gconst72=((-1.0)*(x574.value));
IkReal gconst73=((-1.0)*new_r01*x572);
IkReal gconst74=(new_r11*x572);
CheckValue<IkReal> x575 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x575.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x575.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
CheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
IkReal x576=((-1.0)*(x578.value));
IkReal x577=x572;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x576;
IkReal gconst72=x576;
IkReal gconst73=((-1.0)*new_r01*x577);
IkReal gconst74=(new_r11*x577);
IkReal x579=new_r01*new_r01;
IkReal x580=(new_r00*new_r01);
IkReal x581=(((new_r10*new_r11))+x580);
IkReal x582=x572;
IkReal x583=(new_r01*x582);
j2eval[0]=x581;
j2eval[1]=IKsign(x581);
j2eval[2]=((IKabs((((x580*x582))+((new_r11*x583)))))+(IKabs(((((-1.0)*x579*x582))+((new_r10*x583))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x586 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x586.valid){
continue;
}
IkReal x584=((-1.0)*(x586.value));
IkReal x585=x572;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x584;
IkReal gconst72=x584;
IkReal gconst73=((-1.0)*new_r01*x585);
IkReal gconst74=(new_r11*x585);
IkReal x587=((new_r01*new_r01)+(new_r11*new_r11));
j2eval[0]=x587;
j2eval[1]=IKsign(x587);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x590 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x590.valid){
continue;
}
IkReal x588=((-1.0)*(x590.value));
IkReal x589=x572;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x588;
IkReal gconst72=x588;
IkReal gconst73=((-1.0)*new_r01*x589);
IkReal gconst74=(new_r11*x589);
IkReal x591=new_r01*new_r01;
IkReal x592=new_r11*new_r11;
IkReal x593=((1.0)*x591);
CheckValue<IkReal> x599=IKPowWithIntegerCheck((x592+x591),-1);
if(!x599.valid){
continue;
}
IkReal x594=x599.value;
CheckValue<IkReal> x600=IKPowWithIntegerCheck(((((-1.0)*x592))+(((-1.0)*x593))),-1);
if(!x600.valid){
continue;
}
IkReal x595=x600.value;
IkReal x596=((1.0)*x595);
IkReal x597=(new_r11*x596);
IkReal x598=(new_r01*x596);
j2eval[0]=((IKabs(((((-1.0)*new_r01*x597))+(((-1.0)*x597*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x597*(new_r11*new_r11))))))+(IKabs(((((-1.0)*x593*x594))+((x591*x592*x594))+((x594*(x592*x592)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x602 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x602.valid){
continue;
}
IkReal x601=((-1.0)*(x602.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x601;
new_r11=0;
new_r00=0;
IkReal gconst72=x601;
IkReal x603 = new_r01*new_r01;
if(IKabs(x603)==0){
continue;
}
IkReal gconst73=((-1.0)*new_r01*(pow(x603,-0.5)));
IkReal gconst74=0;
j2eval[0]=new_r10;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x604=IKPowWithIntegerCheck(gconst73,-1);
if(!x604.valid){
continue;
}
cj2array[0]=((-1.0)*new_r10*(x604.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x605=IKsin(j2);
IkReal x606=IKcos(j2);
IkReal x607=((-1.0)*x605);
evalcond[0]=(new_r10*x605);
evalcond[1]=(new_r01*x607);
evalcond[2]=(gconst73*x607);
evalcond[3]=(gconst73+((new_r10*x606)));
evalcond[4]=(gconst73+((new_r01*x606)));
evalcond[5]=(((gconst73*x606))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x608=IKPowWithIntegerCheck(new_r10,-1);
if(!x608.valid){
continue;
}
cj2array[0]=((-1.0)*gconst73*(x608.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x609=IKsin(j2);
IkReal x610=IKcos(j2);
IkReal x611=(gconst73*x610);
IkReal x612=((-1.0)*x609);
evalcond[0]=(new_r10*x609);
evalcond[1]=(new_r01*x612);
evalcond[2]=(gconst73*x612);
evalcond[3]=(x611+new_r10);
evalcond[4]=(gconst73+((new_r01*x610)));
evalcond[5]=(x611+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst73;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
CheckValue<IkReal> x614 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x614.valid){
continue;
}
IkReal x613=((-1.0)*(x614.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x613;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst72=x613;
IkReal gconst73=((-1.0)*new_r01);
IkReal gconst74=new_r11;
j2eval[0]=-1.0;
j2eval[1]=-1.0;
j2eval[2]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x616 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x616.valid){
continue;
}
IkReal x615=((-1.0)*(x616.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x615;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst72=x615;
IkReal gconst73=((-1.0)*new_r01);
IkReal gconst74=new_r11;
j2eval[0]=-1.0;
j2eval[1]=-1.0;
j2eval[2]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x618 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x618.valid){
continue;
}
IkReal x617=((-1.0)*(x618.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x617;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst72=x617;
IkReal gconst73=((-1.0)*new_r01);
IkReal gconst74=new_r11;
j2eval[0]=1.0;
j2eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j2eval[2]=1.0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x619=((1.0)*gconst73);
CheckValue<IkReal> x620 = IKatan2WithCheck(IkReal((((gconst74*new_r01))+(((-1.0)*new_r11*x619)))),IkReal(((((-1.0)*gconst74*new_r11))+(((-1.0)*new_r01*x619)))),IKFAST_ATAN2_MAGTHRESH);
if(!x620.valid){
continue;
}
CheckValue<IkReal> x621=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x621.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x620.value)+(((1.5707963267949)*(x621.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x622=IKcos(j2);
IkReal x623=IKsin(j2);
IkReal x624=(gconst73*x622);
IkReal x625=(gconst73*x623);
IkReal x626=((1.0)*x623);
IkReal x627=(gconst74*x622);
IkReal x628=(gconst74*x626);
evalcond[0]=((((-1.0)*x628))+x624);
evalcond[1]=(gconst73+((new_r01*x622))+((new_r11*x623)));
evalcond[2]=(x625+x627+new_r11);
evalcond[3]=((((-1.0)*new_r01*x626))+gconst74+((new_r11*x622)));
evalcond[4]=((((-1.0)*x627))+(((-1.0)*x625)));
evalcond[5]=((((-1.0)*x628))+x624+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x629=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst73*gconst73)))+(((-1.0)*(gconst74*gconst74))))),-1);
if(!x629.valid){
continue;
}
CheckValue<IkReal> x630 = IKatan2WithCheck(IkReal((gconst73*new_r11)),IkReal((gconst74*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x630.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x629.value)))+(x630.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x631=IKcos(j2);
IkReal x632=IKsin(j2);
IkReal x633=(gconst73*x631);
IkReal x634=(gconst73*x632);
IkReal x635=((1.0)*x632);
IkReal x636=(gconst74*x631);
IkReal x637=(gconst74*x635);
evalcond[0]=((((-1.0)*x637))+x633);
evalcond[1]=(gconst73+((new_r01*x631))+((new_r11*x632)));
evalcond[2]=(x636+x634+new_r11);
evalcond[3]=((((-1.0)*new_r01*x635))+gconst74+((new_r11*x631)));
evalcond[4]=((((-1.0)*x634))+(((-1.0)*x636)));
evalcond[5]=((((-1.0)*x637))+x633+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x638=IKPowWithIntegerCheck(IKsign((((gconst73*new_r01))+(((-1.0)*gconst74*new_r11)))),-1);
if(!x638.valid){
continue;
}
CheckValue<IkReal> x639 = IKatan2WithCheck(IkReal((gconst73*gconst74)),IkReal(gconst74*gconst74),IKFAST_ATAN2_MAGTHRESH);
if(!x639.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x638.value)))+(x639.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x640=IKcos(j2);
IkReal x641=IKsin(j2);
IkReal x642=(gconst73*x640);
IkReal x643=(gconst73*x641);
IkReal x644=((1.0)*x641);
IkReal x645=(gconst74*x640);
IkReal x646=(gconst74*x644);
evalcond[0]=((((-1.0)*x646))+x642);
evalcond[1]=(gconst73+((new_r11*x641))+((new_r01*x640)));
evalcond[2]=(x645+x643+new_r11);
evalcond[3]=(gconst74+((new_r11*x640))+(((-1.0)*new_r01*x644)));
evalcond[4]=((((-1.0)*x645))+(((-1.0)*x643)));
evalcond[5]=((((-1.0)*x646))+x642+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x647=IKPowWithIntegerCheck(gconst74,-1);
if(!x647.valid){
continue;
}
cj2array[0]=(new_r00*(x647.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x648=IKsin(j2);
IkReal x649=IKcos(j2);
IkReal x650=((-1.0)*x648);
evalcond[0]=(new_r11*x648);
evalcond[1]=(new_r00*x650);
evalcond[2]=(gconst74*x650);
evalcond[3]=(gconst74+((new_r11*x649)));
evalcond[4]=(((gconst74*x649))+new_r11);
evalcond[5]=((((-1.0)*gconst74))+((new_r00*x649)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x652 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x652.valid){
continue;
}
IkReal x651=((-1.0)*(x652.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x651;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst72=x651;
IkReal gconst73=0;
IkReal x653 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x653)==0){
continue;
}
IkReal gconst74=(new_r11*(pow(x653,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x655 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x655.valid){
continue;
}
IkReal x654=((-1.0)*(x655.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x654;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst72=x654;
IkReal gconst73=0;
IkReal x656 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x656)==0){
continue;
}
IkReal gconst74=(new_r11*(pow(x656,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x658 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x658.valid){
continue;
}
IkReal x657=((-1.0)*(x658.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x657;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst72=x657;
IkReal gconst73=0;
IkReal x659 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x659)==0){
continue;
}
IkReal gconst74=(new_r11*(pow(x659,-0.5)));
j2eval[0]=new_r10;
j2eval[1]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x660=IKPowWithIntegerCheck(new_r10,-1);
if(!x660.valid){
continue;
}
CheckValue<IkReal> x661=IKPowWithIntegerCheck(new_r11,-1);
if(!x661.valid){
continue;
}
if( IKabs((gconst74*(x660.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst74*(x661.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst74*(x660.value)))+IKsqr(((-1.0)*gconst74*(x661.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((gconst74*(x660.value)), ((-1.0)*gconst74*(x661.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x662=IKcos(j2);
IkReal x663=IKsin(j2);
IkReal x664=((1.0)*gconst74);
IkReal x665=(gconst74*x662);
evalcond[0]=(new_r10*x662);
evalcond[1]=(new_r11*x663);
evalcond[2]=((-1.0)*x665);
evalcond[3]=((-1.0)*gconst74*x663);
evalcond[4]=(gconst74+((new_r11*x662)));
evalcond[5]=(x665+new_r11);
evalcond[6]=((((-1.0)*x663*x664))+new_r10);
evalcond[7]=(((new_r10*x663))+(((-1.0)*x664)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x666=IKPowWithIntegerCheck(gconst74,-1);
if(!x666.valid){
continue;
}
CheckValue<IkReal> x667=IKPowWithIntegerCheck(new_r11,-1);
if(!x667.valid){
continue;
}
if( IKabs((new_r10*(x666.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst74*(x667.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x666.value)))+IKsqr(((-1.0)*gconst74*(x667.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x666.value)), ((-1.0)*gconst74*(x667.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x668=IKcos(j2);
IkReal x669=IKsin(j2);
IkReal x670=((1.0)*gconst74);
IkReal x671=(gconst74*x668);
evalcond[0]=(new_r10*x668);
evalcond[1]=(new_r11*x669);
evalcond[2]=((-1.0)*x671);
evalcond[3]=((-1.0)*gconst74*x669);
evalcond[4]=(gconst74+((new_r11*x668)));
evalcond[5]=(x671+new_r11);
evalcond[6]=((((-1.0)*x669*x670))+new_r10);
evalcond[7]=(((new_r10*x669))+(((-1.0)*x670)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x672 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x672.valid){
continue;
}
CheckValue<IkReal> x673=IKPowWithIntegerCheck(IKsign(gconst74),-1);
if(!x673.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x672.value)+(((1.5707963267949)*(x673.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x674=IKcos(j2);
IkReal x675=IKsin(j2);
IkReal x676=((1.0)*gconst74);
IkReal x677=(gconst74*x674);
evalcond[0]=(new_r10*x674);
evalcond[1]=(new_r11*x675);
evalcond[2]=((-1.0)*x677);
evalcond[3]=((-1.0)*gconst74*x675);
evalcond[4]=(((new_r11*x674))+gconst74);
evalcond[5]=(x677+new_r11);
evalcond[6]=((((-1.0)*x675*x676))+new_r10);
evalcond[7]=(((new_r10*x675))+(((-1.0)*x676)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x679 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x679.valid){
continue;
}
IkReal x678=((-1.0)*(x679.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x678;
new_r01=0;
IkReal gconst72=x678;
IkReal gconst73=0;
IkReal x680 = new_r11*new_r11;
if(IKabs(x680)==0){
continue;
}
IkReal gconst74=(new_r11*(pow(x680,-0.5)));
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x682 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x682.valid){
continue;
}
IkReal x681=((-1.0)*(x682.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x681;
new_r01=0;
IkReal gconst72=x681;
IkReal gconst73=0;
IkReal x683 = new_r11*new_r11;
if(IKabs(x683)==0){
continue;
}
IkReal gconst74=(new_r11*(pow(x683,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x685 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x685.valid){
continue;
}
IkReal x684=((-1.0)*(x685.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x684;
new_r01=0;
IkReal gconst72=x684;
IkReal gconst73=0;
IkReal x686 = new_r11*new_r11;
if(IKabs(x686)==0){
continue;
}
IkReal gconst74=(new_r11*(pow(x686,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x687=IKPowWithIntegerCheck(gconst74,-1);
if(!x687.valid){
continue;
}
CheckValue<IkReal> x688=IKPowWithIntegerCheck(new_r11,-1);
if(!x688.valid){
continue;
}
if( IKabs((new_r10*(x687.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst74*(x688.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x687.value)))+IKsqr(((-1.0)*gconst74*(x688.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x687.value)), ((-1.0)*gconst74*(x688.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x689=IKsin(j2);
IkReal x690=IKcos(j2);
IkReal x691=((1.0)*gconst74);
IkReal x692=((1.0)*x689);
evalcond[0]=(new_r11*x689);
evalcond[1]=((-1.0)*gconst74*x689);
evalcond[2]=(gconst74+((new_r11*x690)));
evalcond[3]=(((gconst74*x690))+new_r11);
evalcond[4]=((((-1.0)*x689*x691))+new_r10);
evalcond[5]=((((-1.0)*x690*x691))+new_r00);
evalcond[6]=(((new_r10*x690))+(((-1.0)*new_r00*x692)));
evalcond[7]=((((-1.0)*x691))+((new_r00*x690))+((new_r10*x689)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x693 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x693.valid){
continue;
}
CheckValue<IkReal> x694=IKPowWithIntegerCheck(IKsign(gconst74),-1);
if(!x694.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x693.value)+(((1.5707963267949)*(x694.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x695=IKsin(j2);
IkReal x696=IKcos(j2);
IkReal x697=((1.0)*gconst74);
IkReal x698=((1.0)*x695);
evalcond[0]=(new_r11*x695);
evalcond[1]=((-1.0)*gconst74*x695);
evalcond[2]=(gconst74+((new_r11*x696)));
evalcond[3]=(((gconst74*x696))+new_r11);
evalcond[4]=((((-1.0)*x695*x697))+new_r10);
evalcond[5]=((((-1.0)*x696*x697))+new_r00);
evalcond[6]=(((new_r10*x696))+(((-1.0)*new_r00*x698)));
evalcond[7]=(((new_r10*x695))+(((-1.0)*x697))+((new_r00*x696)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x699=IKPowWithIntegerCheck(IKsign(gconst74),-1);
if(!x699.valid){
continue;
}
CheckValue<IkReal> x700 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x700.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x699.value)))+(x700.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x701=IKsin(j2);
IkReal x702=IKcos(j2);
IkReal x703=((1.0)*gconst74);
IkReal x704=((1.0)*x701);
evalcond[0]=(new_r11*x701);
evalcond[1]=((-1.0)*gconst74*x701);
evalcond[2]=(gconst74+((new_r11*x702)));
evalcond[3]=(((gconst74*x702))+new_r11);
evalcond[4]=(new_r10+(((-1.0)*x701*x703)));
evalcond[5]=((((-1.0)*x702*x703))+new_r00);
evalcond[6]=(((new_r10*x702))+(((-1.0)*new_r00*x704)));
evalcond[7]=(((new_r00*x702))+(((-1.0)*x703))+((new_r10*x701)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x705=((1.0)*new_r11);
CheckValue<IkReal> x706=IKPowWithIntegerCheck(IKsign((((gconst73*new_r01))+(((-1.0)*gconst74*x705)))),-1);
if(!x706.valid){
continue;
}
CheckValue<IkReal> x707 = IKatan2WithCheck(IkReal((((gconst73*gconst74))+(((-1.0)*new_r01*x705)))),IkReal(((((-1.0)*(gconst73*gconst73)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x706.value)))+(x707.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x708=IKsin(j2);
IkReal x709=IKcos(j2);
IkReal x710=((1.0)*gconst74);
IkReal x711=(gconst73*x709);
IkReal x712=(gconst73*x708);
IkReal x713=((1.0)*x708);
IkReal x714=(x708*x710);
evalcond[0]=(((new_r01*x709))+gconst73+((new_r11*x708)));
evalcond[1]=(((gconst74*x709))+x712+new_r11);
evalcond[2]=(gconst73+((new_r10*x709))+(((-1.0)*new_r00*x713)));
evalcond[3]=(gconst74+((new_r11*x709))+(((-1.0)*new_r01*x713)));
evalcond[4]=((((-1.0)*x714))+x711+new_r10);
evalcond[5]=((((-1.0)*x714))+x711+new_r01);
evalcond[6]=(((new_r00*x709))+(((-1.0)*x710))+((new_r10*x708)));
evalcond[7]=((((-1.0)*x709*x710))+(((-1.0)*x712))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x715=((1.0)*gconst73);
CheckValue<IkReal> x716 = IKatan2WithCheck(IkReal((((gconst74*new_r01))+(((-1.0)*new_r11*x715)))),IkReal(((((-1.0)*gconst74*new_r11))+(((-1.0)*new_r01*x715)))),IKFAST_ATAN2_MAGTHRESH);
if(!x716.valid){
continue;
}
CheckValue<IkReal> x717=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x717.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x716.value)+(((1.5707963267949)*(x717.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x718=IKsin(j2);
IkReal x719=IKcos(j2);
IkReal x720=((1.0)*gconst74);
IkReal x721=(gconst73*x719);
IkReal x722=(gconst73*x718);
IkReal x723=((1.0)*x718);
IkReal x724=(x718*x720);
evalcond[0]=(((new_r01*x719))+gconst73+((new_r11*x718)));
evalcond[1]=(((gconst74*x719))+x722+new_r11);
evalcond[2]=(gconst73+((new_r10*x719))+(((-1.0)*new_r00*x723)));
evalcond[3]=(gconst74+((new_r11*x719))+(((-1.0)*new_r01*x723)));
evalcond[4]=((((-1.0)*x724))+x721+new_r10);
evalcond[5]=((((-1.0)*x724))+x721+new_r01);
evalcond[6]=(((new_r00*x719))+(((-1.0)*x720))+((new_r10*x718)));
evalcond[7]=((((-1.0)*x722))+new_r00+(((-1.0)*x719*x720)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x725=((1.0)*gconst73);
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal((((gconst73*new_r01))+(((-1.0)*new_r10*x725)))),IkReal(((((-1.0)*new_r00*x725))+(((-1.0)*new_r11*x725)))),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
CheckValue<IkReal> x727=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x727.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x726.value)+(((1.5707963267949)*(x727.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x728=IKsin(j2);
IkReal x729=IKcos(j2);
IkReal x730=((1.0)*gconst74);
IkReal x731=(gconst73*x729);
IkReal x732=(gconst73*x728);
IkReal x733=((1.0)*x728);
IkReal x734=(x728*x730);
evalcond[0]=(gconst73+((new_r01*x729))+((new_r11*x728)));
evalcond[1]=(((gconst74*x729))+x732+new_r11);
evalcond[2]=(gconst73+(((-1.0)*new_r00*x733))+((new_r10*x729)));
evalcond[3]=(gconst74+(((-1.0)*new_r01*x733))+((new_r11*x729)));
evalcond[4]=((((-1.0)*x734))+x731+new_r10);
evalcond[5]=((((-1.0)*x734))+x731+new_r01);
evalcond[6]=(((new_r00*x729))+(((-1.0)*x730))+((new_r10*x728)));
evalcond[7]=((((-1.0)*x732))+new_r00+(((-1.0)*x729*x730)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x736 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x736)==0){
continue;
}
IkReal x735=pow(x736,-0.5);
CheckValue<IkReal> x737 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x737.valid){
continue;
}
IkReal gconst75=((3.14159265358979)+(((-1.0)*(x737.value))));
IkReal gconst76=((1.0)*new_r01*x735);
IkReal gconst77=((-1.0)*new_r11*x735);
CheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x738.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x738.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
CheckValue<IkReal> x741 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x741.valid){
continue;
}
IkReal x739=((1.0)*(x741.value));
IkReal x740=x735;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x739)));
IkReal gconst75=((3.14159265358979)+(((-1.0)*x739)));
IkReal gconst76=((1.0)*new_r01*x740);
IkReal gconst77=((-1.0)*new_r11*x740);
IkReal x742=new_r01*new_r01;
IkReal x743=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x744=x735;
IkReal x745=((1.0)*new_r01*x744);
j2eval[0]=x743;
j2eval[1]=IKsign(x743);
j2eval[2]=((IKabs((((x742*x744))+(((-1.0)*new_r10*x745)))))+(IKabs(((((-1.0)*new_r00*x745))+(((-1.0)*new_r11*x745))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x748 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x748.valid){
continue;
}
IkReal x746=((1.0)*(x748.value));
IkReal x747=x735;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x746)));
IkReal gconst75=((3.14159265358979)+(((-1.0)*x746)));
IkReal gconst76=((1.0)*new_r01*x747);
IkReal gconst77=((-1.0)*new_r11*x747);
IkReal x749=((new_r01*new_r01)+(new_r11*new_r11));
j2eval[0]=x749;
j2eval[1]=IKsign(x749);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x752 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x752.valid){
continue;
}
IkReal x750=((1.0)*(x752.value));
IkReal x751=x735;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x750)));
IkReal gconst75=((3.14159265358979)+(((-1.0)*x750)));
IkReal gconst76=((1.0)*new_r01*x751);
IkReal gconst77=((-1.0)*new_r11*x751);
IkReal x753=new_r01*new_r01;
IkReal x754=new_r11*new_r11;
IkReal x755=((1.0)*x753);
CheckValue<IkReal> x761=IKPowWithIntegerCheck((x754+x753),-1);
if(!x761.valid){
continue;
}
IkReal x756=x761.value;
CheckValue<IkReal> x762=IKPowWithIntegerCheck(((((-1.0)*x754))+(((-1.0)*x755))),-1);
if(!x762.valid){
continue;
}
IkReal x757=x762.value;
IkReal x758=((1.0)*x757);
IkReal x759=(new_r11*x758);
IkReal x760=(new_r01*x758);
j2eval[0]=((IKabs((((x753*x754*x756))+(((-1.0)*x755*x756))+((x756*(x754*x754))))))+(IKabs(((((-1.0)*new_r01*x759))+(((-1.0)*new_r01*x759*(new_r11*new_r11)))+(((-1.0)*x759*(new_r01*new_r01*new_r01)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x764 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x764.valid){
continue;
}
IkReal x763=((1.0)*(x764.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x763)));
new_r11=0;
new_r00=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x763)));
IkReal x765 = new_r01*new_r01;
if(IKabs(x765)==0){
continue;
}
IkReal gconst76=((1.0)*new_r01*(pow(x765,-0.5)));
IkReal gconst77=0;
j2eval[0]=new_r10;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x766=IKPowWithIntegerCheck(gconst76,-1);
if(!x766.valid){
continue;
}
cj2array[0]=((-1.0)*new_r10*(x766.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x767=IKsin(j2);
IkReal x768=IKcos(j2);
IkReal x769=((-1.0)*x767);
evalcond[0]=(new_r10*x767);
evalcond[1]=(new_r01*x769);
evalcond[2]=(gconst76*x769);
evalcond[3]=(((new_r10*x768))+gconst76);
evalcond[4]=(gconst76+((new_r01*x768)));
evalcond[5]=(new_r01+((gconst76*x768)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x770=IKPowWithIntegerCheck(new_r10,-1);
if(!x770.valid){
continue;
}
cj2array[0]=((-1.0)*gconst76*(x770.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x771=IKsin(j2);
IkReal x772=IKcos(j2);
IkReal x773=(gconst76*x772);
IkReal x774=((-1.0)*x771);
evalcond[0]=(new_r10*x771);
evalcond[1]=(new_r01*x774);
evalcond[2]=(gconst76*x774);
evalcond[3]=(x773+new_r10);
evalcond[4]=(gconst76+((new_r01*x772)));
evalcond[5]=(x773+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst76;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
CheckValue<IkReal> x776 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x776.valid){
continue;
}
IkReal x775=((1.0)*(x776.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x775)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x775)));
IkReal gconst76=((1.0)*new_r01);
IkReal gconst77=((-1.0)*new_r11);
j2eval[0]=1.0;
j2eval[1]=((IKabs(((1.0)+(((-1.0)*(new_r01*new_r01))))))+(IKabs(((1.0)*new_r01*new_r11))));
j2eval[2]=1.0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x778 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x778.valid){
continue;
}
IkReal x777=((1.0)*(x778.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x777)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x777)));
IkReal gconst76=((1.0)*new_r01);
IkReal gconst77=((-1.0)*new_r11);
j2eval[0]=-1.0;
j2eval[1]=-1.0;
j2eval[2]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x780 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x780.valid){
continue;
}
IkReal x779=((1.0)*(x780.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x779)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x779)));
IkReal gconst76=((1.0)*new_r01);
IkReal gconst77=((-1.0)*new_r11);
j2eval[0]=1.0;
j2eval[1]=1.0;
j2eval[2]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x781=((1.0)*new_r11);
CheckValue<IkReal> x782 = IKatan2WithCheck(IkReal((((gconst77*new_r01))+(((-1.0)*gconst76*x781)))),IkReal(((((-1.0)*gconst77*x781))+(((-1.0)*gconst76*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x782.valid){
continue;
}
CheckValue<IkReal> x783=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x783.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x782.value)+(((1.5707963267949)*(x783.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x784=IKcos(j2);
IkReal x785=IKsin(j2);
IkReal x786=((1.0)*gconst77);
IkReal x787=(gconst76*x784);
IkReal x788=((1.0)*x785);
IkReal x789=(x785*x786);
evalcond[0]=((((-1.0)*x789))+x787);
evalcond[1]=(((new_r11*x785))+gconst76+((new_r01*x784)));
evalcond[2]=(((gconst77*x784))+new_r11+((gconst76*x785)));
evalcond[3]=((((-1.0)*new_r01*x788))+((new_r11*x784))+gconst77);
evalcond[4]=((((-1.0)*gconst76*x788))+(((-1.0)*x784*x786)));
evalcond[5]=((((-1.0)*x789))+x787+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x790 = IKatan2WithCheck(IkReal((gconst76*new_r11)),IkReal((gconst77*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x790.valid){
continue;
}
CheckValue<IkReal> x791=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst76*gconst76)))+(((-1.0)*(gconst77*gconst77))))),-1);
if(!x791.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x790.value)+(((1.5707963267949)*(x791.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x792=IKcos(j2);
IkReal x793=IKsin(j2);
IkReal x794=((1.0)*gconst77);
IkReal x795=(gconst76*x792);
IkReal x796=((1.0)*x793);
IkReal x797=(x793*x794);
evalcond[0]=((((-1.0)*x797))+x795);
evalcond[1]=(((new_r11*x793))+gconst76+((new_r01*x792)));
evalcond[2]=(((gconst76*x793))+new_r11+((gconst77*x792)));
evalcond[3]=((((-1.0)*new_r01*x796))+((new_r11*x792))+gconst77);
evalcond[4]=((((-1.0)*x792*x794))+(((-1.0)*gconst76*x796)));
evalcond[5]=((((-1.0)*x797))+x795+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x798=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst77*new_r11))+((gconst76*new_r01)))),-1);
if(!x798.valid){
continue;
}
CheckValue<IkReal> x799 = IKatan2WithCheck(IkReal((gconst76*gconst77)),IkReal(gconst77*gconst77),IKFAST_ATAN2_MAGTHRESH);
if(!x799.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x798.value)))+(x799.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x800=IKcos(j2);
IkReal x801=IKsin(j2);
IkReal x802=((1.0)*gconst77);
IkReal x803=(gconst76*x800);
IkReal x804=((1.0)*x801);
IkReal x805=(x801*x802);
evalcond[0]=(x803+(((-1.0)*x805)));
evalcond[1]=(gconst76+((new_r11*x801))+((new_r01*x800)));
evalcond[2]=(((gconst76*x801))+((gconst77*x800))+new_r11);
evalcond[3]=((((-1.0)*new_r01*x804))+gconst77+((new_r11*x800)));
evalcond[4]=((((-1.0)*gconst76*x804))+(((-1.0)*x800*x802)));
evalcond[5]=(new_r01+x803+(((-1.0)*x805)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x806=IKPowWithIntegerCheck(gconst77,-1);
if(!x806.valid){
continue;
}
cj2array[0]=(new_r00*(x806.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x807=IKsin(j2);
IkReal x808=IKcos(j2);
IkReal x809=((-1.0)*x807);
evalcond[0]=(new_r11*x807);
evalcond[1]=(new_r00*x809);
evalcond[2]=(gconst77*x809);
evalcond[3]=(gconst77+((new_r11*x808)));
evalcond[4]=(((gconst77*x808))+new_r11);
evalcond[5]=((((-1.0)*gconst77))+((new_r00*x808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x811 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x811.valid){
continue;
}
IkReal x810=((1.0)*(x811.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x810)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x810)));
IkReal gconst76=0;
IkReal x812 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x812)==0){
continue;
}
IkReal gconst77=((-1.0)*new_r11*(pow(x812,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
IkReal x813=((1.0)*(x814.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x813)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x813)));
IkReal gconst76=0;
IkReal x815 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x815)==0){
continue;
}
IkReal gconst77=((-1.0)*new_r11*(pow(x815,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x817 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x817.valid){
continue;
}
IkReal x816=((1.0)*(x817.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x816)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x816)));
IkReal gconst76=0;
IkReal x818 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x818)==0){
continue;
}
IkReal gconst77=((-1.0)*new_r11*(pow(x818,-0.5)));
j2eval[0]=new_r10;
j2eval[1]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x819=IKPowWithIntegerCheck(new_r10,-1);
if(!x819.valid){
continue;
}
CheckValue<IkReal> x820=IKPowWithIntegerCheck(new_r11,-1);
if(!x820.valid){
continue;
}
if( IKabs((gconst77*(x819.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst77*(x820.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst77*(x819.value)))+IKsqr(((-1.0)*gconst77*(x820.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((gconst77*(x819.value)), ((-1.0)*gconst77*(x820.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x821=IKcos(j2);
IkReal x822=IKsin(j2);
IkReal x823=(gconst77*x822);
IkReal x824=(gconst77*x821);
evalcond[0]=(new_r10*x821);
evalcond[1]=(new_r11*x822);
evalcond[2]=((-1.0)*x824);
evalcond[3]=((-1.0)*x823);
evalcond[4]=(gconst77+((new_r11*x821)));
evalcond[5]=(new_r11+x824);
evalcond[6]=((((-1.0)*x823))+new_r10);
evalcond[7]=((((-1.0)*gconst77))+((new_r10*x822)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x825=IKPowWithIntegerCheck(gconst77,-1);
if(!x825.valid){
continue;
}
CheckValue<IkReal> x826=IKPowWithIntegerCheck(new_r11,-1);
if(!x826.valid){
continue;
}
if( IKabs((new_r10*(x825.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst77*(x826.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x825.value)))+IKsqr(((-1.0)*gconst77*(x826.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x825.value)), ((-1.0)*gconst77*(x826.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x827=IKcos(j2);
IkReal x828=IKsin(j2);
IkReal x829=(gconst77*x828);
IkReal x830=(gconst77*x827);
evalcond[0]=(new_r10*x827);
evalcond[1]=(new_r11*x828);
evalcond[2]=((-1.0)*x830);
evalcond[3]=((-1.0)*x829);
evalcond[4]=(gconst77+((new_r11*x827)));
evalcond[5]=(new_r11+x830);
evalcond[6]=((((-1.0)*x829))+new_r10);
evalcond[7]=((((-1.0)*gconst77))+((new_r10*x828)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x831 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x831.valid){
continue;
}
CheckValue<IkReal> x832=IKPowWithIntegerCheck(IKsign(gconst77),-1);
if(!x832.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x831.value)+(((1.5707963267949)*(x832.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x833=IKcos(j2);
IkReal x834=IKsin(j2);
IkReal x835=(gconst77*x834);
IkReal x836=(gconst77*x833);
evalcond[0]=(new_r10*x833);
evalcond[1]=(new_r11*x834);
evalcond[2]=((-1.0)*x836);
evalcond[3]=((-1.0)*x835);
evalcond[4]=(((new_r11*x833))+gconst77);
evalcond[5]=(new_r11+x836);
evalcond[6]=((((-1.0)*x835))+new_r10);
evalcond[7]=((((-1.0)*gconst77))+((new_r10*x834)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x838 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x838.valid){
continue;
}
IkReal x837=((1.0)*(x838.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x837)));
new_r01=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x837)));
IkReal gconst76=0;
IkReal x839 = new_r11*new_r11;
if(IKabs(x839)==0){
continue;
}
IkReal gconst77=((-1.0)*new_r11*(pow(x839,-0.5)));
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x841 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x841.valid){
continue;
}
IkReal x840=((1.0)*(x841.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x840)));
new_r01=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x840)));
IkReal gconst76=0;
IkReal x842 = new_r11*new_r11;
if(IKabs(x842)==0){
continue;
}
IkReal gconst77=((-1.0)*new_r11*(pow(x842,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x844 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x844.valid){
continue;
}
IkReal x843=((1.0)*(x844.value));
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x843)));
new_r01=0;
IkReal gconst75=((3.14159265358979)+(((-1.0)*x843)));
IkReal gconst76=0;
IkReal x845 = new_r11*new_r11;
if(IKabs(x845)==0){
continue;
}
IkReal gconst77=((-1.0)*new_r11*(pow(x845,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x846=IKPowWithIntegerCheck(gconst77,-1);
if(!x846.valid){
continue;
}
CheckValue<IkReal> x847=IKPowWithIntegerCheck(new_r11,-1);
if(!x847.valid){
continue;
}
if( IKabs((new_r10*(x846.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst77*(x847.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x846.value)))+IKsqr(((-1.0)*gconst77*(x847.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x846.value)), ((-1.0)*gconst77*(x847.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x848=IKsin(j2);
IkReal x849=IKcos(j2);
IkReal x850=((1.0)*gconst77);
evalcond[0]=(new_r11*x848);
evalcond[1]=((-1.0)*gconst77*x848);
evalcond[2]=(gconst77+((new_r11*x849)));
evalcond[3]=(((gconst77*x849))+new_r11);
evalcond[4]=((((-1.0)*x848*x850))+new_r10);
evalcond[5]=((((-1.0)*x849*x850))+new_r00);
evalcond[6]=(((new_r10*x849))+(((-1.0)*new_r00*x848)));
evalcond[7]=(((new_r10*x848))+(((-1.0)*x850))+((new_r00*x849)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x851 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x851.valid){
continue;
}
CheckValue<IkReal> x852=IKPowWithIntegerCheck(IKsign(gconst77),-1);
if(!x852.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x851.value)+(((1.5707963267949)*(x852.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x853=IKsin(j2);
IkReal x854=IKcos(j2);
IkReal x855=((1.0)*gconst77);
evalcond[0]=(new_r11*x853);
evalcond[1]=((-1.0)*gconst77*x853);
evalcond[2]=(gconst77+((new_r11*x854)));
evalcond[3]=(((gconst77*x854))+new_r11);
evalcond[4]=((((-1.0)*x853*x855))+new_r10);
evalcond[5]=(new_r00+(((-1.0)*x854*x855)));
evalcond[6]=((((-1.0)*new_r00*x853))+((new_r10*x854)));
evalcond[7]=((((-1.0)*x855))+((new_r10*x853))+((new_r00*x854)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x856=IKPowWithIntegerCheck(IKsign(gconst77),-1);
if(!x856.valid){
continue;
}
CheckValue<IkReal> x857 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x857.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x856.value)))+(x857.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x858=IKsin(j2);
IkReal x859=IKcos(j2);
IkReal x860=((1.0)*gconst77);
evalcond[0]=(new_r11*x858);
evalcond[1]=((-1.0)*gconst77*x858);
evalcond[2]=(gconst77+((new_r11*x859)));
evalcond[3]=(((gconst77*x859))+new_r11);
evalcond[4]=((((-1.0)*x858*x860))+new_r10);
evalcond[5]=((((-1.0)*x859*x860))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x858))+((new_r10*x859)));
evalcond[7]=((((-1.0)*x860))+((new_r10*x858))+((new_r00*x859)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x861=((1.0)*new_r11);
CheckValue<IkReal> x862=IKPowWithIntegerCheck(IKsign((((gconst76*new_r01))+(((-1.0)*gconst77*x861)))),-1);
if(!x862.valid){
continue;
}
CheckValue<IkReal> x863 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x861))+((gconst76*gconst77)))),IkReal(((((-1.0)*(gconst76*gconst76)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x863.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x862.value)))+(x863.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x864=IKcos(j2);
IkReal x865=IKsin(j2);
IkReal x866=((1.0)*gconst77);
IkReal x867=(gconst76*x864);
IkReal x868=((1.0)*x865);
IkReal x869=(x865*x866);
evalcond[0]=(((new_r01*x864))+gconst76+((new_r11*x865)));
evalcond[1]=(((gconst77*x864))+((gconst76*x865))+new_r11);
evalcond[2]=((((-1.0)*new_r00*x868))+gconst76+((new_r10*x864)));
evalcond[3]=((((-1.0)*new_r01*x868))+gconst77+((new_r11*x864)));
evalcond[4]=((((-1.0)*x869))+new_r10+x867);
evalcond[5]=((((-1.0)*x869))+new_r01+x867);
evalcond[6]=((((-1.0)*x866))+((new_r00*x864))+((new_r10*x865)));
evalcond[7]=((((-1.0)*gconst76*x868))+(((-1.0)*x864*x866))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x870=((1.0)*new_r11);
CheckValue<IkReal> x871=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x871.valid){
continue;
}
CheckValue<IkReal> x872 = IKatan2WithCheck(IkReal((((gconst77*new_r01))+(((-1.0)*gconst76*x870)))),IkReal(((((-1.0)*gconst76*new_r01))+(((-1.0)*gconst77*x870)))),IKFAST_ATAN2_MAGTHRESH);
if(!x872.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x871.value)))+(x872.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x873=IKcos(j2);
IkReal x874=IKsin(j2);
IkReal x875=((1.0)*gconst77);
IkReal x876=(gconst76*x873);
IkReal x877=((1.0)*x874);
IkReal x878=(x874*x875);
evalcond[0]=(((new_r01*x873))+gconst76+((new_r11*x874)));
evalcond[1]=(((gconst77*x873))+((gconst76*x874))+new_r11);
evalcond[2]=((((-1.0)*new_r00*x877))+gconst76+((new_r10*x873)));
evalcond[3]=(gconst77+(((-1.0)*new_r01*x877))+((new_r11*x873)));
evalcond[4]=(new_r10+x876+(((-1.0)*x878)));
evalcond[5]=(new_r01+x876+(((-1.0)*x878)));
evalcond[6]=(((new_r00*x873))+((new_r10*x874))+(((-1.0)*x875)));
evalcond[7]=((((-1.0)*gconst76*x877))+(((-1.0)*x873*x875))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x879=((1.0)*gconst76);
CheckValue<IkReal> x880 = IKatan2WithCheck(IkReal((((gconst76*new_r01))+(((-1.0)*new_r10*x879)))),IkReal(((((-1.0)*new_r00*x879))+(((-1.0)*new_r11*x879)))),IKFAST_ATAN2_MAGTHRESH);
if(!x880.valid){
continue;
}
CheckValue<IkReal> x881=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x881.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x880.value)+(((1.5707963267949)*(x881.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x882=IKcos(j2);
IkReal x883=IKsin(j2);
IkReal x884=((1.0)*gconst77);
IkReal x885=(gconst76*x882);
IkReal x886=((1.0)*x883);
IkReal x887=(x883*x884);
evalcond[0]=(((new_r01*x882))+((new_r11*x883))+gconst76);
evalcond[1]=(((gconst77*x882))+new_r11+((gconst76*x883)));
evalcond[2]=(((new_r10*x882))+gconst76+(((-1.0)*new_r00*x886)));
evalcond[3]=(((new_r11*x882))+gconst77+(((-1.0)*new_r01*x886)));
evalcond[4]=((((-1.0)*x887))+new_r10+x885);
evalcond[5]=((((-1.0)*x887))+new_r01+x885);
evalcond[6]=(((new_r10*x883))+((new_r00*x882))+(((-1.0)*x884)));
evalcond[7]=((((-1.0)*x882*x884))+(((-1.0)*gconst76*x886))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r01=0;
new_r11=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x889 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x889.valid){
continue;
}
IkReal x888=x889.value;
j2array[0]=((-1.0)*x888);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x888)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j2))))+((new_r10*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x890=IKcos(j2);
IkReal x891=IKsin(j2);
IkReal x892=((1.0)*x891);
evalcond[0]=(new_r11+x890);
evalcond[1]=((((-1.0)*x892))+new_r10);
evalcond[2]=((((-1.0)*x890))+new_r00);
evalcond[3]=((((-1.0)*x892))+new_r01);
evalcond[4]=(((new_r11*x891))+((new_r01*x890)));
evalcond[5]=(((new_r10*x890))+(((-1.0)*new_r00*x892)));
evalcond[6]=((-1.0)+((new_r00*x890))+((new_r10*x891)));
evalcond[7]=((1.0)+((new_r11*x890))+(((-1.0)*new_r01*x892)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r00));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x893=IKsin(j2);
IkReal x894=IKcos(j2);
IkReal x895=((1.0)*x893);
evalcond[0]=(new_r10+x893);
evalcond[1]=(new_r00+x894);
evalcond[2]=(new_r01+x893);
evalcond[3]=((((-1.0)*x894))+new_r11);
evalcond[4]=(((new_r11*x893))+((new_r01*x894)));
evalcond[5]=(((new_r10*x894))+(((-1.0)*new_r00*x895)));
evalcond[6]=((1.0)+((new_r00*x894))+((new_r10*x893)));
evalcond[7]=((-1.0)+((new_r11*x894))+(((-1.0)*new_r01*x895)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r11=0;
new_r00=0;
j2eval[0]=new_r01;
j2eval[1]=((IKabs(cj4))+(IKabs(sj4)));
j2eval[2]=IKsign(new_r01);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r11=0;
new_r00=0;
j2eval[0]=new_r10;
j2eval[1]=((IKabs(cj4))+(IKabs(sj4)));
j2eval[2]=IKsign(new_r10);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r11=0;
new_r00=0;
j2eval[0]=new_r01;
j2eval[1]=new_r10;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x896=IKPowWithIntegerCheck(new_r01,-1);
if(!x896.valid){
continue;
}
CheckValue<IkReal> x897=IKPowWithIntegerCheck(new_r10,-1);
if(!x897.valid){
continue;
}
if( IKabs((cj4*(x896.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj4*(x897.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj4*(x896.value)))+IKsqr(((-1.0)*sj4*(x897.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((cj4*(x896.value)), ((-1.0)*sj4*(x897.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x898=IKcos(j2);
IkReal x899=IKsin(j2);
IkReal x900=((1.0)*cj4);
IkReal x901=(sj4*x898);
IkReal x902=((1.0)*x899);
IkReal x903=(x899*x900);
evalcond[0]=(sj4+((new_r10*x898)));
evalcond[1]=(sj4+((new_r01*x898)));
evalcond[2]=(cj4+(((-1.0)*new_r01*x902)));
evalcond[3]=(((new_r10*x899))+(((-1.0)*x900)));
evalcond[4]=((((-1.0)*x903))+new_r10+x901);
evalcond[5]=((((-1.0)*x898*x900))+(((-1.0)*sj4*x902)));
evalcond[6]=((((-1.0)*x903))+new_r01+x901);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x904=IKPowWithIntegerCheck(IKsign(new_r10),-1);
if(!x904.valid){
continue;
}
CheckValue<IkReal> x905 = IKatan2WithCheck(IkReal(cj4),IkReal(((-1.0)*sj4)),IKFAST_ATAN2_MAGTHRESH);
if(!x905.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x904.value)))+(x905.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x906=IKcos(j2);
IkReal x907=IKsin(j2);
IkReal x908=((1.0)*cj4);
IkReal x909=(sj4*x906);
IkReal x910=((1.0)*x907);
IkReal x911=(x907*x908);
evalcond[0]=(sj4+((new_r10*x906)));
evalcond[1]=(sj4+((new_r01*x906)));
evalcond[2]=(cj4+(((-1.0)*new_r01*x910)));
evalcond[3]=((((-1.0)*x908))+((new_r10*x907)));
evalcond[4]=((((-1.0)*x911))+new_r10+x909);
evalcond[5]=((((-1.0)*sj4*x910))+(((-1.0)*x906*x908)));
evalcond[6]=((((-1.0)*x911))+new_r01+x909);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x912=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x912.valid){
continue;
}
CheckValue<IkReal> x913 = IKatan2WithCheck(IkReal(cj4),IkReal(((-1.0)*sj4)),IKFAST_ATAN2_MAGTHRESH);
if(!x913.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x912.value)))+(x913.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x914=IKcos(j2);
IkReal x915=IKsin(j2);
IkReal x916=((1.0)*cj4);
IkReal x917=(sj4*x914);
IkReal x918=((1.0)*x915);
IkReal x919=(x915*x916);
evalcond[0]=(sj4+((new_r10*x914)));
evalcond[1]=(sj4+((new_r01*x914)));
evalcond[2]=(cj4+(((-1.0)*new_r01*x918)));
evalcond[3]=((((-1.0)*x916))+((new_r10*x915)));
evalcond[4]=((((-1.0)*x919))+new_r10+x917);
evalcond[5]=((((-1.0)*sj4*x918))+(((-1.0)*x914*x916)));
evalcond[6]=((((-1.0)*x919))+new_r01+x917);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x921 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x921.valid){
continue;
}
IkReal x920=x921.value;
j2array[0]=((-1.0)*x920);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x920)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j2))))+((new_r10*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x923 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x923.valid){
continue;
}
IkReal x922=x923.value;
j2array[0]=((-1.0)*x922);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x922)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r01*(IKsin(j2))))+((new_r11*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r01=0;
new_r10=0;
j2eval[0]=new_r11;
j2eval[1]=IKsign(new_r11);
j2eval[2]=((IKabs(cj4))+(IKabs(sj4)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r01=0;
new_r10=0;
j2eval[0]=new_r00;
j2eval[1]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x924=IKPowWithIntegerCheck(new_r00,-1);
if(!x924.valid){
continue;
}
CheckValue<IkReal> x925=IKPowWithIntegerCheck(new_r11,-1);
if(!x925.valid){
continue;
}
if( IKabs((sj4*(x924.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj4*(x925.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj4*(x924.value)))+IKsqr(((-1.0)*cj4*(x925.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((sj4*(x924.value)), ((-1.0)*cj4*(x925.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x926=IKsin(j2);
IkReal x927=IKcos(j2);
IkReal x928=((1.0)*cj4);
IkReal x929=((1.0)*x926);
evalcond[0]=(cj4+((new_r11*x927)));
evalcond[1]=(sj4+((new_r11*x926)));
evalcond[2]=(sj4+(((-1.0)*new_r00*x929)));
evalcond[3]=((((-1.0)*x928))+((new_r00*x927)));
evalcond[4]=(((sj4*x927))+(((-1.0)*x926*x928)));
evalcond[5]=(((sj4*x926))+new_r11+((cj4*x927)));
evalcond[6]=((((-1.0)*sj4*x929))+(((-1.0)*x927*x928))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x930=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x930.valid){
continue;
}
CheckValue<IkReal> x931 = IKatan2WithCheck(IkReal(((-1.0)*sj4)),IkReal(((-1.0)*cj4)),IKFAST_ATAN2_MAGTHRESH);
if(!x931.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x930.value)))+(x931.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x932=IKsin(j2);
IkReal x933=IKcos(j2);
IkReal x934=((1.0)*cj4);
IkReal x935=((1.0)*x932);
evalcond[0]=(cj4+((new_r11*x933)));
evalcond[1]=(sj4+((new_r11*x932)));
evalcond[2]=(sj4+(((-1.0)*new_r00*x935)));
evalcond[3]=(((new_r00*x933))+(((-1.0)*x934)));
evalcond[4]=(((sj4*x933))+(((-1.0)*x932*x934)));
evalcond[5]=(((sj4*x932))+new_r11+((cj4*x933)));
evalcond[6]=((((-1.0)*sj4*x935))+new_r00+(((-1.0)*x933*x934)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x936=IKPowWithIntegerCheck(IKsign((((cj4*new_r01))+((new_r11*sj4)))),-1);
if(!x936.valid){
continue;
}
CheckValue<IkReal> x937 = IKatan2WithCheck(IkReal(((-1.0)+((new_r01*new_r10))+(cj4*cj4))),IkReal(((((-1.0)*cj4*sj4))+(((-1.0)*new_r10*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x937.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x936.value)))+(x937.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x938=IKsin(j2);
IkReal x939=IKcos(j2);
IkReal x940=((1.0)*cj4);
IkReal x941=(sj4*x939);
IkReal x942=((1.0)*x938);
IkReal x943=(x938*x940);
evalcond[0]=(sj4+((new_r01*x939))+((new_r11*x938)));
evalcond[1]=(((sj4*x938))+new_r11+((cj4*x939)));
evalcond[2]=(sj4+((new_r10*x939))+(((-1.0)*new_r00*x942)));
evalcond[3]=(cj4+(((-1.0)*new_r01*x942))+((new_r11*x939)));
evalcond[4]=((((-1.0)*x943))+new_r10+x941);
evalcond[5]=((((-1.0)*x943))+new_r01+x941);
evalcond[6]=((((-1.0)*x940))+((new_r00*x939))+((new_r10*x938)));
evalcond[7]=((((-1.0)*sj4*x942))+(((-1.0)*x939*x940))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x944=((1.0)*new_r11);
CheckValue<IkReal> x945 = IKatan2WithCheck(IkReal((((cj4*new_r01))+(((-1.0)*sj4*x944)))),IkReal(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x944)))),IKFAST_ATAN2_MAGTHRESH);
if(!x945.valid){
continue;
}
CheckValue<IkReal> x946=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x946.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x945.value)+(((1.5707963267949)*(x946.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x947=IKsin(j2);
IkReal x948=IKcos(j2);
IkReal x949=((1.0)*cj4);
IkReal x950=(sj4*x948);
IkReal x951=((1.0)*x947);
IkReal x952=(x947*x949);
evalcond[0]=(sj4+((new_r01*x948))+((new_r11*x947)));
evalcond[1]=(((sj4*x947))+new_r11+((cj4*x948)));
evalcond[2]=(sj4+(((-1.0)*new_r00*x951))+((new_r10*x948)));
evalcond[3]=(cj4+(((-1.0)*new_r01*x951))+((new_r11*x948)));
evalcond[4]=(new_r10+(((-1.0)*x952))+x950);
evalcond[5]=(new_r01+(((-1.0)*x952))+x950);
evalcond[6]=((((-1.0)*x949))+((new_r00*x948))+((new_r10*x947)));
evalcond[7]=((((-1.0)*x948*x949))+new_r00+(((-1.0)*sj4*x951)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x953=((1.0)*sj4);
CheckValue<IkReal> x954 = IKatan2WithCheck(IkReal((((new_r01*sj4))+(((-1.0)*new_r10*x953)))),IkReal(((((-1.0)*new_r00*x953))+(((-1.0)*new_r11*x953)))),IKFAST_ATAN2_MAGTHRESH);
if(!x954.valid){
continue;
}
CheckValue<IkReal> x955=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x955.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x954.value)+(((1.5707963267949)*(x955.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x956=IKsin(j2);
IkReal x957=IKcos(j2);
IkReal x958=((1.0)*cj4);
IkReal x959=(sj4*x957);
IkReal x960=((1.0)*x956);
IkReal x961=(x956*x958);
evalcond[0]=(sj4+((new_r01*x957))+((new_r11*x956)));
evalcond[1]=(((sj4*x956))+new_r11+((cj4*x957)));
evalcond[2]=(((new_r10*x957))+sj4+(((-1.0)*new_r00*x960)));
evalcond[3]=(cj4+(((-1.0)*new_r01*x960))+((new_r11*x957)));
evalcond[4]=(new_r10+x959+(((-1.0)*x961)));
evalcond[5]=(new_r01+x959+(((-1.0)*x961)));
evalcond[6]=(((new_r10*x956))+((new_r00*x957))+(((-1.0)*x958)));
evalcond[7]=((((-1.0)*x957*x958))+new_r00+(((-1.0)*sj4*x960)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x962=((-1.0)*new_r22);
CheckValue<IkReal> x964 = IKatan2WithCheck(IkReal((new_r01*x962)),IkReal((new_r11*x962)),IKFAST_ATAN2_MAGTHRESH);
if(!x964.valid){
continue;
}
IkReal x963=x964.value;
j2array[0]=((-1.0)*x963);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x963)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x965=IKcos(j2);
IkReal x966=IKsin(j2);
IkReal x967=((1.0)*new_r00);
IkReal x968=(new_r10*x966);
evalcond[0]=(((new_r00*x965))+x968);
evalcond[1]=(((new_r11*x966))+((new_r01*x965)));
evalcond[2]=((((-1.0)*x966*x967))+((new_r10*x965)));
evalcond[3]=(((new_r11*x965))+(((-1.0)*new_r01*x966)));
evalcond[4]=((((-1.0)*new_r22*x968))+(((-1.0)*new_r22*x965*x967)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x970 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x970.valid){
continue;
}
IkReal x969=x970.value;
j2array[0]=((-1.0)*x969);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x969)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x971=IKcos(j2);
IkReal x972=IKsin(j2);
IkReal x973=((1.0)*new_r22);
IkReal x974=(new_r00*x971);
IkReal x975=((1.0)*x972);
IkReal x976=(new_r10*x972);
evalcond[0]=(x974+x976);
evalcond[1]=((((-1.0)*new_r00*x975))+((new_r10*x971)));
evalcond[2]=((((-1.0)*new_r01*x975))+((new_r11*x971)));
evalcond[3]=((((-1.0)*new_r11*x972*x973))+(((-1.0)*new_r01*x971*x973)));
evalcond[4]=((((-1.0)*x973*x974))+(((-1.0)*x973*x976)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x978 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x978.valid){
continue;
}
IkReal x977=x978.value;
j2array[0]=((-1.0)*x977);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x977)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x979=IKcos(j2);
IkReal x980=IKsin(j2);
IkReal x981=((1.0)*new_r22);
IkReal x982=(new_r11*x980);
IkReal x983=((1.0)*x980);
IkReal x984=(new_r01*x979);
evalcond[0]=(x984+x982);
evalcond[1]=((((-1.0)*new_r00*x983))+((new_r10*x979)));
evalcond[2]=((((-1.0)*new_r01*x983))+((new_r11*x979)));
evalcond[3]=((((-1.0)*x981*x984))+(((-1.0)*x981*x982)));
evalcond[4]=((((-1.0)*new_r10*x980*x981))+(((-1.0)*new_r00*x979*x981)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x986=IKPowWithIntegerCheck(sj3,-1);
if(!x986.valid){
continue;
}
IkReal x985=x986.value;
CheckValue<IkReal> x987=IKPowWithIntegerCheck(new_r00,-1);
if(!x987.valid){
continue;
}
if( IKabs((x985*(x987.value)*((((sj3*sj4))+((new_r02*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x985)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x985*(x987.value)*((((sj3*sj4))+((new_r02*new_r10))))))+IKsqr((new_r02*x985))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x985*(x987.value)*((((sj3*sj4))+((new_r02*new_r10))))), (new_r02*x985));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x988=IKcos(j2);
IkReal x989=IKsin(j2);
IkReal x990=(cj3*cj4);
IkReal x991=((1.0)*sj4);
IkReal x992=((1.0)*cj3);
IkReal x993=(sj3*x989);
IkReal x994=(new_r01*x988);
IkReal x995=(cj3*x988);
IkReal x996=(new_r11*x989);
IkReal x997=((1.0)*x989);
IkReal x998=(sj3*x988);
evalcond[0]=((((-1.0)*x998))+new_r02);
evalcond[1]=((((-1.0)*x993))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x997))+((new_r12*x988)));
evalcond[3]=(sj4+(((-1.0)*new_r00*x997))+((new_r10*x988)));
evalcond[4]=(cj4+(((-1.0)*new_r01*x997))+((new_r11*x988)));
evalcond[5]=(((x989*x990))+((sj4*x988))+new_r10);
evalcond[6]=((((-1.0)*sj3))+((new_r02*x988))+((new_r12*x989)));
evalcond[7]=(((new_r00*x988))+((new_r10*x989))+x990);
evalcond[8]=(((x988*x990))+new_r00+(((-1.0)*x989*x991)));
evalcond[9]=(((cj4*x988))+(((-1.0)*cj3*x989*x991))+new_r11);
evalcond[10]=((((-1.0)*cj3*x991))+x996+x994);
evalcond[11]=((((-1.0)*cj4*x997))+(((-1.0)*x991*x995))+new_r01);
evalcond[12]=(((new_r10*x993))+((new_r00*x998))+((cj3*new_r20)));
evalcond[13]=(((new_r11*x993))+((sj3*x994))+((cj3*new_r21)));
evalcond[14]=((-1.0)+((new_r12*x993))+((new_r02*x998))+((cj3*new_r22)));
evalcond[15]=((((-1.0)*new_r02*x988*x992))+((new_r22*sj3))+(((-1.0)*new_r12*x989*x992)));
evalcond[16]=(sj4+(((-1.0)*x992*x994))+(((-1.0)*x992*x996))+((new_r21*sj3)));
evalcond[17]=(((new_r20*sj3))+(((-1.0)*new_r10*x989*x992))+(((-1.0)*cj4))+(((-1.0)*new_r00*x988*x992)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x999=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x999.valid){
continue;
}
CheckValue<IkReal> x1000 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x1000.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x999.value)))+(x1000.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x1001=IKcos(j2);
IkReal x1002=IKsin(j2);
IkReal x1003=(cj3*cj4);
IkReal x1004=((1.0)*sj4);
IkReal x1005=((1.0)*cj3);
IkReal x1006=(sj3*x1002);
IkReal x1007=(new_r01*x1001);
IkReal x1008=(cj3*x1001);
IkReal x1009=(new_r11*x1002);
IkReal x1010=((1.0)*x1002);
IkReal x1011=(sj3*x1001);
evalcond[0]=(new_r02+(((-1.0)*x1011)));
evalcond[1]=((((-1.0)*x1006))+new_r12);
evalcond[2]=(((new_r12*x1001))+(((-1.0)*new_r02*x1010)));
evalcond[3]=(sj4+((new_r10*x1001))+(((-1.0)*new_r00*x1010)));
evalcond[4]=(cj4+((new_r11*x1001))+(((-1.0)*new_r01*x1010)));
evalcond[5]=(((sj4*x1001))+new_r10+((x1002*x1003)));
evalcond[6]=((((-1.0)*sj3))+((new_r12*x1002))+((new_r02*x1001)));
evalcond[7]=(x1003+((new_r10*x1002))+((new_r00*x1001)));
evalcond[8]=((((-1.0)*x1002*x1004))+new_r00+((x1001*x1003)));
evalcond[9]=(((cj4*x1001))+(((-1.0)*cj3*x1002*x1004))+new_r11);
evalcond[10]=(x1009+x1007+(((-1.0)*cj3*x1004)));
evalcond[11]=((((-1.0)*cj4*x1010))+(((-1.0)*x1004*x1008))+new_r01);
evalcond[12]=(((new_r10*x1006))+((new_r00*x1011))+((cj3*new_r20)));
evalcond[13]=(((new_r11*x1006))+((sj3*x1007))+((cj3*new_r21)));
evalcond[14]=((-1.0)+((new_r02*x1011))+((new_r12*x1006))+((cj3*new_r22)));
evalcond[15]=((((-1.0)*new_r12*x1002*x1005))+(((-1.0)*new_r02*x1001*x1005))+((new_r22*sj3)));
evalcond[16]=(sj4+(((-1.0)*x1005*x1009))+(((-1.0)*x1005*x1007))+((new_r21*sj3)));
evalcond[17]=((((-1.0)*new_r00*x1001*x1005))+((new_r20*sj3))+(((-1.0)*new_r10*x1002*x1005))+(((-1.0)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x1012=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x1012.valid){
continue;
}
CheckValue<IkReal> x1013 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x1013.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1012.value)))+(x1013.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x1014=IKcos(j2);
IkReal x1015=IKsin(j2);
IkReal x1016=((1.0)*new_r02);
IkReal x1017=(sj3*x1015);
IkReal x1018=(sj3*x1014);
IkReal x1019=(new_r12*x1015);
evalcond[0]=(new_r02+(((-1.0)*x1018)));
evalcond[1]=(new_r12+(((-1.0)*x1017)));
evalcond[2]=((((-1.0)*x1015*x1016))+((new_r12*x1014)));
evalcond[3]=(((new_r02*x1014))+(((-1.0)*sj3))+x1019);
evalcond[4]=(((new_r10*x1017))+((new_r00*x1018))+((cj3*new_r20)));
evalcond[5]=(((new_r11*x1017))+((new_r01*x1018))+((cj3*new_r21)));
evalcond[6]=((-1.0)+((new_r02*x1018))+((new_r12*x1017))+((cj3*new_r22)));
evalcond[7]=((((-1.0)*cj3*x1014*x1016))+(((-1.0)*cj3*x1019))+((new_r22*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=IKsign(sj3);
j4eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=cj3;
j4eval[2]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1020=((1.0)*cj2);
if( IKabs((((new_r00*sj2))+(((-1.0)*new_r10*x1020)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*x1020))+(((-1.0)*new_r10*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj2))+(((-1.0)*new_r10*x1020))))+IKsqr(((((-1.0)*new_r00*x1020))+(((-1.0)*new_r10*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*sj2))+(((-1.0)*new_r10*x1020))), ((((-1.0)*new_r00*x1020))+(((-1.0)*new_r10*sj2))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1021=IKcos(j4);
IkReal x1022=IKsin(j4);
IkReal x1023=((1.0)*sj2);
IkReal x1024=(cj2*x1021);
IkReal x1025=((1.0)*x1022);
IkReal x1026=(x1022*x1023);
evalcond[0]=(x1021+((new_r10*sj2))+((cj2*new_r00)));
evalcond[1]=((((-1.0)*new_r00*x1023))+x1022+((cj2*new_r10)));
evalcond[2]=(x1021+((cj2*new_r11))+(((-1.0)*new_r01*x1023)));
evalcond[3]=(((cj2*x1022))+new_r10+((sj2*x1021)));
evalcond[4]=(((new_r11*sj2))+(((-1.0)*x1025))+((cj2*new_r01)));
evalcond[5]=(x1024+(((-1.0)*x1026))+new_r00);
evalcond[6]=(x1024+(((-1.0)*x1026))+new_r11);
evalcond[7]=((((-1.0)*x1021*x1023))+(((-1.0)*cj2*x1025))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1027=((1.0)*cj2);
if( IKabs(((((-1.0)*new_r10*x1027))+(((-1.0)*new_r11*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*sj2))+(((-1.0)*new_r11*x1027)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r10*x1027))+(((-1.0)*new_r11*sj2))))+IKsqr((((new_r10*sj2))+(((-1.0)*new_r11*x1027))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r10*x1027))+(((-1.0)*new_r11*sj2))), (((new_r10*sj2))+(((-1.0)*new_r11*x1027))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1028=IKsin(j4);
IkReal x1029=IKcos(j4);
IkReal x1030=((1.0)*sj2);
IkReal x1031=(cj2*x1028);
IkReal x1032=(cj2*x1029);
IkReal x1033=(x1029*x1030);
evalcond[0]=(x1028+((new_r11*sj2))+((cj2*new_r01)));
evalcond[1]=(x1028+((cj2*new_r10))+(((-1.0)*new_r00*x1030)));
evalcond[2]=(x1029+((cj2*new_r11))+(((-1.0)*new_r01*x1030)));
evalcond[3]=(((new_r10*sj2))+(((-1.0)*x1029))+((cj2*new_r00)));
evalcond[4]=(x1032+new_r11+((sj2*x1028)));
evalcond[5]=((((-1.0)*x1033))+x1031+new_r10);
evalcond[6]=((((-1.0)*x1033))+x1031+new_r01);
evalcond[7]=((((-1.0)*x1028*x1030))+(((-1.0)*x1032))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1034=IKsin(j4);
IkReal x1035=IKcos(j4);
IkReal x1036=((1.0)*sj2);
evalcond[0]=(x1034+new_r21);
evalcond[1]=((((-1.0)*x1035))+new_r20);
evalcond[2]=(((cj2*x1034))+new_r10);
evalcond[3]=(((cj2*x1035))+new_r11);
evalcond[4]=((((-1.0)*x1034*x1036))+new_r00);
evalcond[5]=((((-1.0)*x1035*x1036))+new_r01);
evalcond[6]=(x1034+((cj2*new_r10))+(((-1.0)*new_r00*x1036)));
evalcond[7]=(x1035+((cj2*new_r11))+(((-1.0)*new_r01*x1036)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1037=IKsin(j4);
IkReal x1038=IKcos(j4);
IkReal x1039=((1.0)*sj2);
evalcond[0]=(x1038+new_r20);
evalcond[1]=((((-1.0)*x1037))+new_r21);
evalcond[2]=(((cj2*x1037))+new_r10);
evalcond[3]=(((cj2*x1038))+new_r11);
evalcond[4]=((((-1.0)*x1037*x1039))+new_r00);
evalcond[5]=((((-1.0)*x1038*x1039))+new_r01);
evalcond[6]=(x1037+((cj2*new_r10))+(((-1.0)*new_r00*x1039)));
evalcond[7]=(x1038+((cj2*new_r11))+(((-1.0)*new_r01*x1039)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1040=IKsin(j4);
IkReal x1041=IKcos(j4);
IkReal x1042=((1.0)*cj3);
IkReal x1043=((1.0)*x1041);
evalcond[0]=(x1040+new_r10);
evalcond[1]=(x1041+new_r11);
evalcond[2]=(((sj3*x1040))+new_r21);
evalcond[3]=(((cj3*x1041))+new_r00);
evalcond[4]=((((-1.0)*sj3*x1043))+new_r20);
evalcond[5]=((((-1.0)*x1040*x1042))+new_r01);
evalcond[6]=(x1040+(((-1.0)*new_r01*x1042))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*new_r00*x1042))+(((-1.0)*x1043)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1044=IKsin(j4);
IkReal x1045=IKcos(j4);
IkReal x1046=((1.0)*x1045);
evalcond[0]=(((sj3*x1044))+new_r21);
evalcond[1]=(x1044+(((-1.0)*new_r10)));
evalcond[2]=(x1045+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*sj3*x1046))+new_r20);
evalcond[4]=(((cj3*x1045))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*cj3*x1044))+(((-1.0)*new_r01)));
evalcond[6]=(x1044+((cj3*new_r01))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+((cj3*new_r00))+(((-1.0)*x1046)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1047=IKsin(j4);
IkReal x1048=IKcos(j4);
IkReal x1049=((1.0)*cj3);
IkReal x1050=((1.0)*x1048);
evalcond[0]=(((sj3*x1047))+new_r21);
evalcond[1]=(x1047+(((-1.0)*new_r00)));
evalcond[2]=(x1048+(((-1.0)*new_r01)));
evalcond[3]=(((cj3*x1048))+new_r10);
evalcond[4]=((((-1.0)*sj3*x1050))+new_r20);
evalcond[5]=(new_r11+(((-1.0)*x1047*x1049)));
evalcond[6]=(x1047+((new_r21*sj3))+(((-1.0)*new_r11*x1049)));
evalcond[7]=((((-1.0)*x1050))+((new_r20*sj3))+(((-1.0)*new_r10*x1049)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1051=IKsin(j4);
IkReal x1052=IKcos(j4);
IkReal x1053=((1.0)*x1052);
evalcond[0]=(x1051+new_r00);
evalcond[1]=(x1052+new_r01);
evalcond[2]=(((sj3*x1051))+new_r21);
evalcond[3]=((((-1.0)*sj3*x1053))+new_r20);
evalcond[4]=(((cj3*x1052))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*cj3*x1051))+(((-1.0)*new_r11)));
evalcond[6]=(x1051+((cj3*new_r11))+((new_r21*sj3)));
evalcond[7]=((((-1.0)*x1053))+((new_r20*sj3))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=((-1.0)*new_r22);
op[1]=0;
op[2]=new_r22;
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1055=IKPowWithIntegerCheck(sj3,-1);
if(!x1055.valid){
continue;
}
IkReal x1054=x1055.value;
CheckValue<IkReal> x1056=IKPowWithIntegerCheck(cj3,-1);
if(!x1056.valid){
continue;
}
CheckValue<IkReal> x1057=IKPowWithIntegerCheck(sj2,-1);
if(!x1057.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x1054)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1054*(x1056.value)*(x1057.value)*(((((-1.0)*new_r10*sj3))+((cj2*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x1054))+IKsqr((x1054*(x1056.value)*(x1057.value)*(((((-1.0)*new_r10*sj3))+((cj2*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x1054), (x1054*(x1056.value)*(x1057.value)*(((((-1.0)*new_r10*sj3))+((cj2*new_r21))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x1058=IKsin(j4);
IkReal x1059=IKcos(j4);
IkReal x1060=(cj2*new_r01);
IkReal x1061=((1.0)*cj3);
IkReal x1062=(new_r10*sj2);
IkReal x1063=(new_r11*sj2);
IkReal x1064=(cj2*new_r00);
IkReal x1065=((1.0)*sj2);
IkReal x1066=(cj2*x1058);
IkReal x1067=(cj2*x1059);
IkReal x1068=((1.0)*x1059);
IkReal x1069=(cj3*x1059);
evalcond[0]=(((sj3*x1058))+new_r21);
evalcond[1]=((((-1.0)*sj3*x1068))+new_r20);
evalcond[2]=(x1058+(((-1.0)*new_r00*x1065))+((cj2*new_r10)));
evalcond[3]=(x1059+(((-1.0)*new_r01*x1065))+((cj2*new_r11)));
evalcond[4]=(x1069+x1062+x1064);
evalcond[5]=(x1066+((sj2*x1069))+new_r10);
evalcond[6]=(x1060+x1063+(((-1.0)*x1058*x1061)));
evalcond[7]=((((-1.0)*x1058*x1065))+((cj3*x1067))+new_r00);
evalcond[8]=((((-1.0)*sj2*x1058*x1061))+x1067+new_r11);
evalcond[9]=((((-1.0)*x1059*x1065))+(((-1.0)*x1061*x1066))+new_r01);
evalcond[10]=((((-1.0)*x1060*x1061))+x1058+(((-1.0)*x1061*x1063))+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+(((-1.0)*x1061*x1062))+(((-1.0)*x1061*x1064))+(((-1.0)*x1068)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1071=IKPowWithIntegerCheck(sj3,-1);
if(!x1071.valid){
continue;
}
IkReal x1070=x1071.value;
CheckValue<IkReal> x1072=IKPowWithIntegerCheck(cj2,-1);
if(!x1072.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x1070)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1070*(x1072.value)*(((((-1.0)*cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x1070))+IKsqr((x1070*(x1072.value)*(((((-1.0)*cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x1070), (x1070*(x1072.value)*(((((-1.0)*cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x1073=IKsin(j4);
IkReal x1074=IKcos(j4);
IkReal x1075=(cj2*new_r01);
IkReal x1076=((1.0)*cj3);
IkReal x1077=(new_r10*sj2);
IkReal x1078=(new_r11*sj2);
IkReal x1079=(cj2*new_r00);
IkReal x1080=((1.0)*sj2);
IkReal x1081=(cj2*x1073);
IkReal x1082=(cj2*x1074);
IkReal x1083=((1.0)*x1074);
IkReal x1084=(cj3*x1074);
evalcond[0]=(((sj3*x1073))+new_r21);
evalcond[1]=((((-1.0)*sj3*x1083))+new_r20);
evalcond[2]=(x1073+(((-1.0)*new_r00*x1080))+((cj2*new_r10)));
evalcond[3]=(x1074+(((-1.0)*new_r01*x1080))+((cj2*new_r11)));
evalcond[4]=(x1079+x1077+x1084);
evalcond[5]=(x1081+((sj2*x1084))+new_r10);
evalcond[6]=(x1078+x1075+(((-1.0)*x1073*x1076)));
evalcond[7]=((((-1.0)*x1073*x1080))+((cj3*x1082))+new_r00);
evalcond[8]=(x1082+(((-1.0)*sj2*x1073*x1076))+new_r11);
evalcond[9]=((((-1.0)*x1074*x1080))+(((-1.0)*x1076*x1081))+new_r01);
evalcond[10]=((((-1.0)*x1075*x1076))+x1073+(((-1.0)*x1076*x1078))+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+(((-1.0)*x1076*x1079))+(((-1.0)*x1076*x1077))+(((-1.0)*x1083)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1085=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x1085.valid){
continue;
}
CheckValue<IkReal> x1086 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x1086.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1085.value)))+(x1086.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x1087=IKsin(j4);
IkReal x1088=IKcos(j4);
IkReal x1089=(cj2*new_r01);
IkReal x1090=((1.0)*cj3);
IkReal x1091=(new_r10*sj2);
IkReal x1092=(new_r11*sj2);
IkReal x1093=(cj2*new_r00);
IkReal x1094=((1.0)*sj2);
IkReal x1095=(cj2*x1087);
IkReal x1096=(cj2*x1088);
IkReal x1097=((1.0)*x1088);
IkReal x1098=(cj3*x1088);
evalcond[0]=(((sj3*x1087))+new_r21);
evalcond[1]=((((-1.0)*sj3*x1097))+new_r20);
evalcond[2]=((((-1.0)*new_r00*x1094))+x1087+((cj2*new_r10)));
evalcond[3]=(x1088+(((-1.0)*new_r01*x1094))+((cj2*new_r11)));
evalcond[4]=(x1091+x1093+x1098);
evalcond[5]=(x1095+((sj2*x1098))+new_r10);
evalcond[6]=(x1092+x1089+(((-1.0)*x1087*x1090)));
evalcond[7]=((((-1.0)*x1087*x1094))+new_r00+((cj3*x1096)));
evalcond[8]=(x1096+(((-1.0)*sj2*x1087*x1090))+new_r11);
evalcond[9]=((((-1.0)*x1088*x1094))+(((-1.0)*x1090*x1095))+new_r01);
evalcond[10]=(x1087+(((-1.0)*x1090*x1092))+(((-1.0)*x1089*x1090))+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+(((-1.0)*x1090*x1091))+(((-1.0)*x1090*x1093))+(((-1.0)*x1097)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - victor (de36c7cd1bbabcfe9a97264b5803b99a)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
